<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Endless ListView in Android | Piotr Wittchen</title>
<meta name=keywords content="android"><meta name=description content="Some time ago, I had to implement Endless ListView in Android application. I checked different solutions, but some of them were overprogrammed or did not work well. Fortunately, I found simple solution, which solves the problem. Code snippet presenting mentioned approach, is placed below.
public class EndlessScrollListener implements OnScrollListener {

    private int visibleThreshold = 20;
    private int currentPage = 0;

    @Override
    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
    }

    @Override
    public void onScrollStateChanged(AbsListView view, int scrollState) {
        if (scrollState == SCROLL_STATE_IDLE) {
            if (listView.getLastVisiblePosition() >= listView.getCount() - visibleThreshold) {
                currentPage++;
                downloadRecordsTask.setPage(currentPage);
                downloadRecordsTask.execute();
            }
        }
    }
}
In this solution, I simply implement OnScrollListener interface inside the activity, which is responsible for displaying the ListView (class presented above can be nested class in the proper activity class). In this case listView attribute represents ListView and downloadRecordsTask in an examplary AsyncTask. Of course, AsyncTask class should also have setPage method used for pagination. Records are loaded asynchronously to the listView, when user is not scrolling the list (SCROLL_STATE_IDLE). In my opinion, this solution is the simplest, the easiest to implement and works as we expect it to work. I have tested it in my project for over 1000 records and I have not encountered any problems during the testing process."><meta name=author content="Piotr Wittchen"><link rel=canonical href=http://localhost:1313/posts/endless-listview-in-android/><link crossorigin=anonymous href=/assets/css/stylesheet.4a824105f186decca41ccc96dd9047842de7c7350551e0447bbf802e4461e6c7.css integrity="sha256-SoJBBfGG3sykHMyW3ZBHhC3nxzUFUeBEe7+ALkRh5sc=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/endless-listview-in-android/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/endless-listview-in-android/"><meta property="og:site_name" content="Piotr Wittchen"><meta property="og:title" content="Endless ListView in Android"><meta property="og:description" content="Some time ago, I had to implement Endless ListView in Android application. I checked different solutions, but some of them were overprogrammed or did not work well. Fortunately, I found simple solution, which solves the problem. Code snippet presenting mentioned approach, is placed below.
public class EndlessScrollListener implements OnScrollListener { private int visibleThreshold = 20; private int currentPage = 0; @Override public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) { } @Override public void onScrollStateChanged(AbsListView view, int scrollState) { if (scrollState == SCROLL_STATE_IDLE) { if (listView.getLastVisiblePosition() >= listView.getCount() - visibleThreshold) { currentPage++; downloadRecordsTask.setPage(currentPage); downloadRecordsTask.execute(); } } } } In this solution, I simply implement OnScrollListener interface inside the activity, which is responsible for displaying the ListView (class presented above can be nested class in the proper activity class). In this case listView attribute represents ListView and downloadRecordsTask in an examplary AsyncTask. Of course, AsyncTask class should also have setPage method used for pagination. Records are loaded asynchronously to the listView, when user is not scrolling the list (SCROLL_STATE_IDLE). In my opinion, this solution is the simplest, the easiest to implement and works as we expect it to work. I have tested it in my project for over 1000 records and I have not encountered any problems during the testing process."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2013-02-14T15:34:00+00:00"><meta property="article:modified_time" content="2013-02-14T15:34:00+00:00"><meta property="article:tag" content="Android"><meta name=twitter:card content="summary"><meta name=twitter:title content="Endless ListView in Android"><meta name=twitter:description content="Some time ago, I had to implement Endless ListView in Android application. I checked different solutions, but some of them were overprogrammed or did not work well. Fortunately, I found simple solution, which solves the problem. Code snippet presenting mentioned approach, is placed below.
public class EndlessScrollListener implements OnScrollListener {

    private int visibleThreshold = 20;
    private int currentPage = 0;

    @Override
    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
    }

    @Override
    public void onScrollStateChanged(AbsListView view, int scrollState) {
        if (scrollState == SCROLL_STATE_IDLE) {
            if (listView.getLastVisiblePosition() >= listView.getCount() - visibleThreshold) {
                currentPage++;
                downloadRecordsTask.setPage(currentPage);
                downloadRecordsTask.execute();
            }
        }
    }
}
In this solution, I simply implement OnScrollListener interface inside the activity, which is responsible for displaying the ListView (class presented above can be nested class in the proper activity class). In this case listView attribute represents ListView and downloadRecordsTask in an examplary AsyncTask. Of course, AsyncTask class should also have setPage method used for pagination. Records are loaded asynchronously to the listView, when user is not scrolling the list (SCROLL_STATE_IDLE). In my opinion, this solution is the simplest, the easiest to implement and works as we expect it to work. I have tested it in my project for over 1000 records and I have not encountered any problems during the testing process."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Endless ListView in Android","item":"http://localhost:1313/posts/endless-listview-in-android/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Endless ListView in Android","name":"Endless ListView in Android","description":"Some time ago, I had to implement Endless ListView in Android application. I checked different solutions, but some of them were overprogrammed or did not work well. Fortunately, I found simple solution, which solves the problem. Code snippet presenting mentioned approach, is placed below.\npublic class EndlessScrollListener implements OnScrollListener { private int visibleThreshold = 20; private int currentPage = 0; @Override public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) { } @Override public void onScrollStateChanged(AbsListView view, int scrollState) { if (scrollState == SCROLL_STATE_IDLE) { if (listView.getLastVisiblePosition() \u0026gt;= listView.getCount() - visibleThreshold) { currentPage++; downloadRecordsTask.setPage(currentPage); downloadRecordsTask.execute(); } } } } In this solution, I simply implement OnScrollListener interface inside the activity, which is responsible for displaying the ListView (class presented above can be nested class in the proper activity class). In this case listView attribute represents ListView and downloadRecordsTask in an examplary AsyncTask. Of course, AsyncTask class should also have setPage method used for pagination. Records are loaded asynchronously to the listView, when user is not scrolling the list (SCROLL_STATE_IDLE). In my opinion, this solution is the simplest, the easiest to implement and works as we expect it to work. I have tested it in my project for over 1000 records and I have not encountered any problems during the testing process.\n","keywords":["android"],"articleBody":"Some time ago, I had to implement Endless ListView in Android application. I checked different solutions, but some of them were overprogrammed or did not work well. Fortunately, I found simple solution, which solves the problem. Code snippet presenting mentioned approach, is placed below.\npublic class EndlessScrollListener implements OnScrollListener { private int visibleThreshold = 20; private int currentPage = 0; @Override public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) { } @Override public void onScrollStateChanged(AbsListView view, int scrollState) { if (scrollState == SCROLL_STATE_IDLE) { if (listView.getLastVisiblePosition() \u003e= listView.getCount() - visibleThreshold) { currentPage++; downloadRecordsTask.setPage(currentPage); downloadRecordsTask.execute(); } } } } In this solution, I simply implement OnScrollListener interface inside the activity, which is responsible for displaying the ListView (class presented above can be nested class in the proper activity class). In this case listView attribute represents ListView and downloadRecordsTask in an examplary AsyncTask. Of course, AsyncTask class should also have setPage method used for pagination. Records are loaded asynchronously to the listView, when user is not scrolling the list (SCROLL_STATE_IDLE). In my opinion, this solution is the simplest, the easiest to implement and works as we expect it to work. I have tested it in my project for over 1000 records and I have not encountered any problems during the testing process.\n","wordCount":"212","inLanguage":"en","datePublished":"2013-02-14T15:34:00Z","dateModified":"2013-02-14T15:34:00Z","author":{"@type":"Person","name":"Piotr Wittchen"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/endless-listview-in-android/"},"publisher":{"@type":"Organization","name":"Piotr Wittchen","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Piotr Wittchen (Alt + H)">Piotr Wittchen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/posts/ title=posts><span>posts</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li><li><a href=http://localhost:1313/talks/ title=talks><span>talks</span></a></li><li><a href=http://localhost:1313/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=http://localhost:1313/contact/ title=contact><span>contact</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Endless ListView in Android</h1><div class=post-meta><span title='2013-02-14 15:34:00 +0000 UTC'>February 14, 2013</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;212 words&nbsp;·&nbsp;Piotr Wittchen&nbsp;|&nbsp;<a href=https://github.com/pwittchen/wittchen.io/blob/master/content/posts/endless-listview-in-android.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Some time ago, I had to implement Endless ListView in Android application. I checked different solutions, but some of them were overprogrammed or did not work well. Fortunately, I found simple solution, which solves the problem. Code snippet presenting mentioned approach, is placed below.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>EndlessScrollListener</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>OnScrollListener</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>visibleThreshold</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>20</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>currentPage</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>onScroll</span><span class=p>(</span><span class=n>AbsListView</span><span class=w> </span><span class=n>view</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>firstVisibleItem</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>visibleItemCount</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>totalItemCount</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>onScrollStateChanged</span><span class=p>(</span><span class=n>AbsListView</span><span class=w> </span><span class=n>view</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>scrollState</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>scrollState</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>SCROLL_STATE_IDLE</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>listView</span><span class=p>.</span><span class=na>getLastVisiblePosition</span><span class=p>()</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>listView</span><span class=p>.</span><span class=na>getCount</span><span class=p>()</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>visibleThreshold</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>currentPage</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>downloadRecordsTask</span><span class=p>.</span><span class=na>setPage</span><span class=p>(</span><span class=n>currentPage</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>downloadRecordsTask</span><span class=p>.</span><span class=na>execute</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>In this solution, I simply implement OnScrollListener interface inside the activity, which is responsible for displaying the ListView (class presented above can be nested class in the proper activity class). In this case listView attribute represents ListView and downloadRecordsTask in an examplary AsyncTask. Of course, AsyncTask class should also have setPage method used for pagination. Records are loaded asynchronously to the listView, when user is not scrolling the list (<code>SCROLL_STATE_IDLE</code>). In my opinion, this solution is the simplest, the easiest to implement and works as we expect it to work. I have tested it in my project for over 1000 records and I have not encountered any problems during the testing process.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/android/>Android</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/distributed-inter-process-communication/><span class=title>« Prev</span><br><span>Distributed inter-process communication</span>
</a><a class=next href=http://localhost:1313/posts/custom-background-for-actionbar-and-sherlockactionbar/><span class=title>Next »</span><br><span>Custom background for ActionBar and SherlockActionBar</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Piotr Wittchen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>