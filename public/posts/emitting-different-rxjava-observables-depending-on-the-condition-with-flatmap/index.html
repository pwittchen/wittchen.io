<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Emitting different observables conditionally | Piotr Wittchen</title><meta name=keywords content="java,rxjava"><meta name=description content="Sometimes, we may need to emit different RxJava Observables depending on the specific condition dynamically. Moreover, it&rsquo;s good to do it right without breaking a chain (stream of Observables). We want to combine different Observables together and do not want to nest one subscription inside another subscription because this will lead us to &ldquo;subscription hell&rdquo; similar to &ldquo;callback hell&rdquo;. Luckily RxJava has mechanisms to deal with such problems. In this article, I&rsquo;m basing my examples on RxJava 2."><meta name=author content="Piotr Wittchen"><link rel=canonical href=https://wittchen.io/posts/emitting-different-rxjava-observables-depending-on-the-condition-with-flatmap/><link crossorigin=anonymous href=/assets/css/stylesheet.cdcf872f971c70fddc7fd480e8457cd308ed0cf287b498bcdc6183fc6d147858.css integrity="sha256-zc+HL5cccP3cf9SA6EV80wjtDPKHtJi83GGD/G0UeFg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://wittchen.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wittchen.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wittchen.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wittchen.io/apple-touch-icon.png><link rel=mask-icon href=https://wittchen.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Emitting different observables conditionally"><meta property="og:description" content="Sometimes, we may need to emit different RxJava Observables depending on the specific condition dynamically. Moreover, it&rsquo;s good to do it right without breaking a chain (stream of Observables). We want to combine different Observables together and do not want to nest one subscription inside another subscription because this will lead us to &ldquo;subscription hell&rdquo; similar to &ldquo;callback hell&rdquo;. Luckily RxJava has mechanisms to deal with such problems. In this article, I&rsquo;m basing my examples on RxJava 2."><meta property="og:type" content="article"><meta property="og:url" content="https://wittchen.io/posts/emitting-different-rxjava-observables-depending-on-the-condition-with-flatmap/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-05-14T21:44:00+00:00"><meta property="article:modified_time" content="2017-05-14T21:44:00+00:00"><meta property="og:site_name" content="Piotr Wittchen"><meta name=twitter:card content="summary"><meta name=twitter:title content="Emitting different observables conditionally"><meta name=twitter:description content="Sometimes, we may need to emit different RxJava Observables depending on the specific condition dynamically. Moreover, it&rsquo;s good to do it right without breaking a chain (stream of Observables). We want to combine different Observables together and do not want to nest one subscription inside another subscription because this will lead us to &ldquo;subscription hell&rdquo; similar to &ldquo;callback hell&rdquo;. Luckily RxJava has mechanisms to deal with such problems. In this article, I&rsquo;m basing my examples on RxJava 2."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wittchen.io/posts/"},{"@type":"ListItem","position":2,"name":"Emitting different observables conditionally","item":"https://wittchen.io/posts/emitting-different-rxjava-observables-depending-on-the-condition-with-flatmap/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Emitting different observables conditionally","name":"Emitting different observables conditionally","description":"Sometimes, we may need to emit different RxJava Observables depending on the specific condition dynamically. Moreover, it\u0026rsquo;s good to do it right without breaking a chain (stream of Observables). We want to combine different Observables together and do not want to nest one subscription inside another subscription because this will lead us to \u0026ldquo;subscription hell\u0026rdquo; similar to \u0026ldquo;callback hell\u0026rdquo;. Luckily RxJava has mechanisms to deal with such problems. In this article, I\u0026rsquo;m basing my examples on RxJava 2.","keywords":["java","rxjava"],"articleBody":"Sometimes, we may need to emit different RxJava Observables depending on the specific condition dynamically. Moreover, it’s good to do it right without breaking a chain (stream of Observables). We want to combine different Observables together and do not want to nest one subscription inside another subscription because this will lead us to “subscription hell” similar to “callback hell”. Luckily RxJava has mechanisms to deal with such problems. In this article, I’m basing my examples on RxJava 2.1.0. Let’s say we have two Observables:\npublic ObservableString trueObservable() { return Observable.fromCallable(() - \"trueObservable\"); } public ObservableString falseObservable() { return Observable.fromCallable(() - \"falseObservable\"); } and we have another Observable wrapping Boolean value:\npublic ObservableBoolean createCondition(boolean returnedValue) { return Observable.fromCallable(() - returnedValue); } This Observable can emit true or false depending on the provided parameter. What we want to do is to:\n emit trueObservable() when createCondition(boolean) returns true emit falseObservable() when createCondition(boolean) returns false emit falseObservable() when createCondition(boolean) emits empty Observable (default behaviour)  We can do it in the following way:\npublic ObservableString emitTrueObservableDynamically() { return createCondition(true) .defaultIfEmpty(false) .flatMap(condition - condition ? trueObservable() : falseObservable()); } In such case, this method will emit trueObservable(). When we change parameter of the createCondition(boolean) method to false, Observable will emit falseObservable(). When we replace createCondition(boolean) method with Observable.empty(), method will return falseObservable() by default. As we can see, it’s easily solved with flatMap and defaultIfEmpty operators. This is quite useful technique, which we can apply to reactive applications to control our flow without breaking the chain. Please note, it’s just an example you can create more complicated constructions and handle more complicated types than just boolean and more than two use cases.\n Reference thread for this article on StackOverflow: http://stackoverflow.com/questions/34195218/rxjava-exequte-observable-only-if-first-was-empty.\n","wordCount":"284","inLanguage":"en","datePublished":"2017-05-14T21:44:00Z","dateModified":"2017-05-14T21:44:00Z","author":{"@type":"Person","name":"Piotr Wittchen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wittchen.io/posts/emitting-different-rxjava-observables-depending-on-the-condition-with-flatmap/"},"publisher":{"@type":"Organization","name":"Piotr Wittchen","logo":{"@type":"ImageObject","url":"https://wittchen.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wittchen.io/ accesskey=h title="Piotr Wittchen (Alt + H)">Piotr Wittchen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wittchen.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://wittchen.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://wittchen.io/talks/ title=talks><span>talks</span></a></li><li><a href=https://wittchen.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://wittchen.io/contact/ title=contact><span>contact</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wittchen.io/>Home</a>&nbsp;»&nbsp;<a href=https://wittchen.io/posts/>Posts</a></div><h1 class=post-title>Emitting different observables conditionally</h1><div class=post-meta><span title="2017-05-14 21:44:00 +0000 UTC">May 14, 2017</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;284 words&nbsp;·&nbsp;Piotr Wittchen&nbsp;|&nbsp;<a href=https://github.com/pwittchen/wittchen.io/blob/master/content/posts/emitting-different-rxjava-observables-depending-on-the-condition-with-flatmap.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Sometimes, we may need to emit different RxJava Observables depending on the specific condition dynamically. Moreover, it&rsquo;s good to do it right without breaking a chain (stream of Observables). We want to combine different Observables together and do not want to nest one subscription inside another subscription because this will lead us to &ldquo;subscription hell&rdquo; similar to &ldquo;callback hell&rdquo;. Luckily RxJava has mechanisms to deal with such problems. In this article, I&rsquo;m basing my examples on RxJava 2.1.0. Let&rsquo;s say we have two Observables:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>Observable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=nf>trueObservable</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>Observable</span><span class=o>.</span><span class=na>fromCallable</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=s>&#34;trueObservable&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>Observable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=nf>falseObservable</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>Observable</span><span class=o>.</span><span class=na>fromCallable</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=s>&#34;falseObservable&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>and we have another Observable wrapping <code>Boolean</code> value:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>Observable</span><span class=o>&lt;</span><span class=n>Boolean</span><span class=o>&gt;</span> <span class=nf>createCondition</span><span class=o>(</span><span class=kt>boolean</span> <span class=n>returnedValue</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>Observable</span><span class=o>.</span><span class=na>fromCallable</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=n>returnedValue</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>This Observable can emit <code>true</code> or <code>false</code> depending on the provided parameter. What we want to do is to:</p><ul><li>emit <code>trueObservable()</code> when <code>createCondition(boolean)</code> returns <code>true</code></li><li>emit <code>falseObservable()</code> when <code>createCondition(boolean)</code> returns <code>false</code></li><li>emit <code>falseObservable()</code> when <code>createCondition(boolean)</code> emits empty Observable (default behaviour)</li></ul><p>We can do it in the following way:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>Observable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=nf>emitTrueObservableDynamically</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>createCondition</span><span class=o>(</span><span class=kc>true</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>defaultIfEmpty</span><span class=o>(</span><span class=kc>false</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>flatMap</span><span class=o>(</span><span class=n>condition</span> <span class=o>-&gt;</span> <span class=n>condition</span> <span class=o>?</span> <span class=n>trueObservable</span><span class=o>()</span> <span class=o>:</span> <span class=n>falseObservable</span><span class=o>());</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>In such case, this method will emit <code>trueObservable()</code>. When we change parameter of the <code>createCondition(boolean)</code> method to false, Observable will emit <code>falseObservable()</code>. When we replace <code>createCondition(boolean)</code> method with <code>Observable.empty()</code>, method will return <code>falseObservable()</code> by default. As we can see, it&rsquo;s easily solved with <a href=http://reactivex.io/documentation/operators/flatmap.html>flatMap</a> and <a href=http://reactivex.io/documentation/operators/defaultifempty.html>defaultIfEmpty</a> operators. This is quite useful technique, which we can apply to reactive applications to control our flow without breaking the chain. Please note, it&rsquo;s just an example you can create more complicated constructions and handle more complicated types than just boolean and more than two use cases.</p><hr><p>Reference thread for this article on StackOverflow: <a href=http://stackoverflow.com/questions/34195218/rxjava-exequte-observable-only-if-first-was-empty>http://stackoverflow.com/questions/34195218/rxjava-exequte-observable-only-if-first-was-empty</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wittchen.io/tags/java/>java</a></li><li><a href=https://wittchen.io/tags/rxjava/>rxjava</a></li></ul><nav class=paginav><a class=prev href=https://wittchen.io/posts/joining-lists-of-rxjava-observables/><span class=title>« Prev</span><br><span>Joining lists of RxJava Observables</span></a>
<a class=next href=https://wittchen.io/posts/basic-code-refactoring-principles/><span class=title>Next »</span><br><span>Basic code refactoring principles</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://wittchen.io/>Piotr Wittchen</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerHTML="copy";function s(){e.innerHTML="copied!",setTimeout(()=>{e.innerHTML="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>