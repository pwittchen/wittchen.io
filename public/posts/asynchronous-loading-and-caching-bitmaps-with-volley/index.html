<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Asynchronous loading and caching bitmaps with Volley | Piotr Wittchen</title>
<meta name=keywords content="android,java"><meta name=description content="We can use Volley library from Google for very clean, simple and easy loading of the images from Internet. Volley uses LRU cache, so first of all, we need to create BitmapLruCache class extending LruCache class.
package com.github.volley.example.toolbox;

import com.android.volley.toolbox.ImageLoader.ImageCache;

import android.graphics.Bitmap;
import android.support.v4.util.LruCache;

public class BitmapLruCache extends LruCache<String, Bitmap> implements ImageCache {
    public BitmapLruCache(int maxSize) {
        super(maxSize);
    }

//    Fix thanks to Steven's comment: sizeOf method should not be overriden, 
//    when we are passing max image cache entries in another place of the code
//    @Override
//    protected int sizeOf(String key, Bitmap value) {
//        return value.getRowBytes() * value.getHeight();
//    }

    @Override
    public Bitmap getBitmap(String url) {
        return get(url);
    }

    @Override
    public void putBitmap(String url, Bitmap bitmap) {
        put(url, bitmap);
    }
}
Next, we need to create VolleyHelper class."><meta name=author content="Piotr Wittchen"><link rel=canonical href=http://localhost:1313/posts/asynchronous-loading-and-caching-bitmaps-with-volley/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/asynchronous-loading-and-caching-bitmaps-with-volley/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/asynchronous-loading-and-caching-bitmaps-with-volley/"><meta property="og:site_name" content="Piotr Wittchen"><meta property="og:title" content="Asynchronous loading and caching bitmaps with Volley"><meta property="og:description" content="We can use Volley library from Google for very clean, simple and easy loading of the images from Internet. Volley uses LRU cache, so first of all, we need to create BitmapLruCache class extending LruCache class.
package com.github.volley.example.toolbox; import com.android.volley.toolbox.ImageLoader.ImageCache; import android.graphics.Bitmap; import android.support.v4.util.LruCache; public class BitmapLruCache extends LruCache<String, Bitmap> implements ImageCache { public BitmapLruCache(int maxSize) { super(maxSize); } // Fix thanks to Steven's comment: sizeOf method should not be overriden, // when we are passing max image cache entries in another place of the code // @Override // protected int sizeOf(String key, Bitmap value) { // return value.getRowBytes() * value.getHeight(); // } @Override public Bitmap getBitmap(String url) { return get(url); } @Override public void putBitmap(String url, Bitmap bitmap) { put(url, bitmap); } } Next, we need to create VolleyHelper class."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2013-08-26T23:37:00+00:00"><meta property="article:modified_time" content="2013-08-26T23:37:00+00:00"><meta property="article:tag" content="Android"><meta property="article:tag" content="Java"><meta name=twitter:card content="summary"><meta name=twitter:title content="Asynchronous loading and caching bitmaps with Volley"><meta name=twitter:description content="We can use Volley library from Google for very clean, simple and easy loading of the images from Internet. Volley uses LRU cache, so first of all, we need to create BitmapLruCache class extending LruCache class.
package com.github.volley.example.toolbox;

import com.android.volley.toolbox.ImageLoader.ImageCache;

import android.graphics.Bitmap;
import android.support.v4.util.LruCache;

public class BitmapLruCache extends LruCache<String, Bitmap> implements ImageCache {
    public BitmapLruCache(int maxSize) {
        super(maxSize);
    }

//    Fix thanks to Steven's comment: sizeOf method should not be overriden, 
//    when we are passing max image cache entries in another place of the code
//    @Override
//    protected int sizeOf(String key, Bitmap value) {
//        return value.getRowBytes() * value.getHeight();
//    }

    @Override
    public Bitmap getBitmap(String url) {
        return get(url);
    }

    @Override
    public void putBitmap(String url, Bitmap bitmap) {
        put(url, bitmap);
    }
}
Next, we need to create VolleyHelper class."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Asynchronous loading and caching bitmaps with Volley","item":"http://localhost:1313/posts/asynchronous-loading-and-caching-bitmaps-with-volley/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Asynchronous loading and caching bitmaps with Volley","name":"Asynchronous loading and caching bitmaps with Volley","description":"We can use Volley library from Google for very clean, simple and easy loading of the images from Internet. Volley uses LRU cache, so first of all, we need to create BitmapLruCache class extending LruCache class.\npackage com.github.volley.example.toolbox; import com.android.volley.toolbox.ImageLoader.ImageCache; import android.graphics.Bitmap; import android.support.v4.util.LruCache; public class BitmapLruCache extends LruCache\u0026lt;String, Bitmap\u0026gt; implements ImageCache { public BitmapLruCache(int maxSize) { super(maxSize); } // Fix thanks to Steven\u0026#39;s comment: sizeOf method should not be overriden, // when we are passing max image cache entries in another place of the code // @Override // protected int sizeOf(String key, Bitmap value) { // return value.getRowBytes() * value.getHeight(); // } @Override public Bitmap getBitmap(String url) { return get(url); } @Override public void putBitmap(String url, Bitmap bitmap) { put(url, bitmap); } } Next, we need to create VolleyHelper class.\n","keywords":["android","java"],"articleBody":"We can use Volley library from Google for very clean, simple and easy loading of the images from Internet. Volley uses LRU cache, so first of all, we need to create BitmapLruCache class extending LruCache class.\npackage com.github.volley.example.toolbox; import com.android.volley.toolbox.ImageLoader.ImageCache; import android.graphics.Bitmap; import android.support.v4.util.LruCache; public class BitmapLruCache extends LruCache\u003cString, Bitmap\u003e implements ImageCache { public BitmapLruCache(int maxSize) { super(maxSize); } // Fix thanks to Steven's comment: sizeOf method should not be overriden, // when we are passing max image cache entries in another place of the code // @Override // protected int sizeOf(String key, Bitmap value) { // return value.getRowBytes() * value.getHeight(); // } @Override public Bitmap getBitmap(String url) { return get(url); } @Override public void putBitmap(String url, Bitmap bitmap) { put(url, bitmap); } } Next, we need to create VolleyHelper class.\npackage com.github.volley.example.toolbox; import android.content.Context; import com.android.volley.RequestQueue; import com.android.volley.toolbox.ImageLoader; import com.android.volley.toolbox.Volley; import com.github.volley.example.toolbox.BitmapLruCache; /** * Helper class that is used to provide references to initialized RequestQueue(s) and ImageLoader(s) */ public class VolleyHelper { private static final int MAX_IMAGE_CACHE_ENTIRES = 100; private static RequestQueue mRequestQueue; private static ImageLoader mImageLoader; private VolleyHelper() { } static void init(Context context) { mRequestQueue = Volley.newRequestQueue(context); mImageLoader = new ImageLoader(mRequestQueue, new BitmapLruCache(MAX_IMAGE_CACHE_ENTIRES)); } public static RequestQueue getRequestQueue() { if (mRequestQueue != null) { return mRequestQueue; } else { throw new IllegalStateException(\"RequestQueue not initialized\"); } } /** * Returns instance of ImageLoader initialized with {@see FakeImageCache} which effectively means * that no memory caching is used. This is useful for images that you know that will be show * only once. */ public static ImageLoader getImageLoader() { if (mImageLoader != null) { return mImageLoader; } else { throw new IllegalStateException(\"ImageLoader not initialized\"); } } } Then, somewhere in our activity, we can use the following code snippet:\nimageView = (ImageView) findViewById(R.id.iv_image); // ... String imageUrl = \"http://www.example.com/image.jpg\"; VolleyHelper.init(this); // we can call this method in other place - e.g. in class extending Application class // and refer to application context insted of activity context ImageLoader imageLoader = VolleyHelper.getImageLoader(); imageLoader.get(imageUrl,ImageLoader.getImageListener(mImageView,R.drawable.no_image, R.drawable.error_image)); // ... As we can see, we can define image in case of error or no image. What is nice and important, Volley will take care of asynchronous downloading of the bitmaps, so we don’t have to create additional AsyncTasks. It will also create cache in temporary memory and on disk with using LRU cache. As we could easily notice, Volley is really good and small, but powerful library, which can make our life easier. It was also created and tested by Google, what assures its stability and quality.\n","wordCount":"422","inLanguage":"en","datePublished":"2013-08-26T23:37:00Z","dateModified":"2013-08-26T23:37:00Z","author":{"@type":"Person","name":"Piotr Wittchen"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/asynchronous-loading-and-caching-bitmaps-with-volley/"},"publisher":{"@type":"Organization","name":"Piotr Wittchen","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Piotr Wittchen (Alt + H)">Piotr Wittchen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/posts/ title=posts><span>posts</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li><li><a href=http://localhost:1313/talks/ title=talks><span>talks</span></a></li><li><a href=http://localhost:1313/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=http://localhost:1313/contact/ title=contact><span>contact</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Asynchronous loading and caching bitmaps with Volley</h1><div class=post-meta><span title='2013-08-26 23:37:00 +0000 UTC'>August 26, 2013</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;422 words&nbsp;·&nbsp;Piotr Wittchen&nbsp;|&nbsp;<a href=https://github.com/pwittchen/wittchen.io/blob/master/content/posts/asynchronous-loading-and-caching-bitmaps-with-volley.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>We can use <a href=https://android.googlesource.com/platform/frameworks/volley/>Volley</a> library from Google for very clean, simple and easy loading of the images from Internet. Volley uses <a href=http://developer.android.com/reference/android/util/LruCache.html>LRU cache</a>, so first of all, we need to create BitmapLruCache class extending LruCache class.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>package</span><span class=w> </span><span class=nn>com.github.volley.example.toolbox</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>com.android.volley.toolbox.ImageLoader.ImageCache</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>android.graphics.Bitmap</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>android.support.v4.util.LruCache</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>BitmapLruCache</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>LruCache</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>Bitmap</span><span class=o>&gt;</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>ImageCache</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>BitmapLruCache</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>maxSize</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>super</span><span class=p>(</span><span class=n>maxSize</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//    Fix thanks to Steven&#39;s comment: sizeOf method should not be overriden, </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//    when we are passing max image cache entries in another place of the code</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//    @Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//    protected int sizeOf(String key, Bitmap value) {</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        return value.getRowBytes() * value.getHeight();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//    }</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Bitmap</span><span class=w> </span><span class=nf>getBitmap</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>url</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>get</span><span class=p>(</span><span class=n>url</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>putBitmap</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>url</span><span class=p>,</span><span class=w> </span><span class=n>Bitmap</span><span class=w> </span><span class=n>bitmap</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>put</span><span class=p>(</span><span class=n>url</span><span class=p>,</span><span class=w> </span><span class=n>bitmap</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Next, we need to create VolleyHelper class.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>package</span><span class=w> </span><span class=nn>com.github.volley.example.toolbox</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>android.content.Context</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>com.android.volley.RequestQueue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>com.android.volley.toolbox.ImageLoader</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>com.android.volley.toolbox.Volley</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>com.github.volley.example.toolbox.BitmapLruCache</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Helper class that is used to provide references to initialized RequestQueue(s) and ImageLoader(s)
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>VolleyHelper</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>MAX_IMAGE_CACHE_ENTIRES</span><span class=w>  </span><span class=o>=</span><span class=w> </span><span class=n>100</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>RequestQueue</span><span class=w> </span><span class=n>mRequestQueue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>ImageLoader</span><span class=w> </span><span class=n>mImageLoader</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=nf>VolleyHelper</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>init</span><span class=p>(</span><span class=n>Context</span><span class=w> </span><span class=n>context</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>mRequestQueue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Volley</span><span class=p>.</span><span class=na>newRequestQueue</span><span class=p>(</span><span class=n>context</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>mImageLoader</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ImageLoader</span><span class=p>(</span><span class=n>mRequestQueue</span><span class=p>,</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>BitmapLruCache</span><span class=p>(</span><span class=n>MAX_IMAGE_CACHE_ENTIRES</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>RequestQueue</span><span class=w> </span><span class=nf>getRequestQueue</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>mRequestQueue</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>mRequestQueue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>IllegalStateException</span><span class=p>(</span><span class=s>&#34;RequestQueue not initialized&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Returns instance of ImageLoader initialized with {@see FakeImageCache} which effectively means
</span></span></span><span class=line><span class=cl><span class=cm>     * that no memory caching is used. This is useful for images that you know that will be show
</span></span></span><span class=line><span class=cl><span class=cm>     * only once.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>ImageLoader</span><span class=w> </span><span class=nf>getImageLoader</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>mImageLoader</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>mImageLoader</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>IllegalStateException</span><span class=p>(</span><span class=s>&#34;ImageLoader not initialized&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Then, somewhere in our activity, we can use the following code snippet:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>imageView</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>ImageView</span><span class=p>)</span><span class=w> </span><span class=n>findViewById</span><span class=p>(</span><span class=n>R</span><span class=p>.</span><span class=na>id</span><span class=p>.</span><span class=na>iv_image</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>String</span><span class=w> </span><span class=n>imageUrl</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;http://www.example.com/image.jpg&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>VolleyHelper</span><span class=p>.</span><span class=na>init</span><span class=p>(</span><span class=k>this</span><span class=p>);</span><span class=w> </span><span class=c1>// we can call this method in other place - e.g. in class extending Application class</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                         </span><span class=c1>// and refer to application context insted of activity context</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>ImageLoader</span><span class=w> </span><span class=n>imageLoader</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>VolleyHelper</span><span class=p>.</span><span class=na>getImageLoader</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>imageLoader</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>imageUrl</span><span class=p>,</span><span class=n>ImageLoader</span><span class=p>.</span><span class=na>getImageListener</span><span class=p>(</span><span class=n>mImageView</span><span class=p>,</span><span class=n>R</span><span class=p>.</span><span class=na>drawable</span><span class=p>.</span><span class=na>no_image</span><span class=p>,</span><span class=w> </span><span class=n>R</span><span class=p>.</span><span class=na>drawable</span><span class=p>.</span><span class=na>error_image</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// ...</span><span class=w>
</span></span></span></code></pre></div><p>As we can see, we can define image in case of error or no image. What is nice and important, Volley will take care of asynchronous downloading of the bitmaps, so we don&rsquo;t have to create additional AsyncTasks. It will also create cache in temporary memory and on disk with using LRU cache. As we could easily notice, Volley is really good and small, but powerful library, which can make our life easier. It was also created and tested by Google, what assures its stability and quality.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/android/>Android</a></li><li><a href=http://localhost:1313/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/justifying-block-of-text-inside-textview-in-android/><span class=title>« Prev</span><br><span>Justifying block of text inside TextView in Android</span>
</a><a class=next href=http://localhost:1313/posts/how-to-change-fragment-layout-on-orientation-change/><span class=title>Next »</span><br><span>How to change Fragment layout on orientation change?</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Piotr Wittchen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>