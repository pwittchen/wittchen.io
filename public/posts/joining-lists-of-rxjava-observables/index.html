<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Joining lists of RxJava Observables | Piotr Wittchen</title><meta name=keywords content="java,rxjava"><meta name=description content="In RxJava we have a few operators for joining Observables. The most common are:
 concat merge zip  Take a look at the documentation in these links. It has interactive marble diagrams showing how the operators work on the streams. You can move marbles along the lines and see how the output stream changes. It really helps to understand how it works. Code snippets in this article are based on RxJava 2."><meta name=author content="Piotr Wittchen"><link rel=canonical href=https://wittchen.io/posts/joining-lists-of-rxjava-observables/><link crossorigin=anonymous href=/assets/css/stylesheet.cdcf872f971c70fddc7fd480e8457cd308ed0cf287b498bcdc6183fc6d147858.css integrity="sha256-zc+HL5cccP3cf9SA6EV80wjtDPKHtJi83GGD/G0UeFg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://wittchen.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wittchen.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wittchen.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wittchen.io/apple-touch-icon.png><link rel=mask-icon href=https://wittchen.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Joining lists of RxJava Observables"><meta property="og:description" content="In RxJava we have a few operators for joining Observables. The most common are:
 concat merge zip  Take a look at the documentation in these links. It has interactive marble diagrams showing how the operators work on the streams. You can move marbles along the lines and see how the output stream changes. It really helps to understand how it works. Code snippets in this article are based on RxJava 2."><meta property="og:type" content="article"><meta property="og:url" content="https://wittchen.io/posts/joining-lists-of-rxjava-observables/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-05-15T20:37:00+00:00"><meta property="article:modified_time" content="2017-05-15T20:37:00+00:00"><meta property="og:site_name" content="Piotr Wittchen"><meta name=twitter:card content="summary"><meta name=twitter:title content="Joining lists of RxJava Observables"><meta name=twitter:description content="In RxJava we have a few operators for joining Observables. The most common are:
 concat merge zip  Take a look at the documentation in these links. It has interactive marble diagrams showing how the operators work on the streams. You can move marbles along the lines and see how the output stream changes. It really helps to understand how it works. Code snippets in this article are based on RxJava 2."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wittchen.io/posts/"},{"@type":"ListItem","position":2,"name":"Joining lists of RxJava Observables","item":"https://wittchen.io/posts/joining-lists-of-rxjava-observables/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Joining lists of RxJava Observables","name":"Joining lists of RxJava Observables","description":"In RxJava we have a few operators for joining Observables. The most common are:\n concat merge zip  Take a look at the documentation in these links. It has interactive marble diagrams showing how the operators work on the streams. You can move marbles along the lines and see how the output stream changes. It really helps to understand how it works. Code snippets in this article are based on RxJava 2.","keywords":["java","rxjava"],"articleBody":"In RxJava we have a few operators for joining Observables. The most common are:\n concat merge zip  Take a look at the documentation in these links. It has interactive marble diagrams showing how the operators work on the streams. You can move marbles along the lines and see how the output stream changes. It really helps to understand how it works. Code snippets in this article are based on RxJava 2.1.0 with JUnit 4.12 and Google Truth 0.32 for unit tests. Let’s say, we have the following Observables:\npublic ObservableString emitNumbers() { return Observable.fromArray(\"1\", \"2\", \"3\", \"4\").delay(1, TimeUnit.SECONDS); } public ObservableString emitLetters() { return Observable.fromArray(\"a\", \"b\", \"c\", \"d\"); } We can merge them in the different ways.\nConcat Concat operator emits the emissions from two or more Observables without interleaving them. We can perform the following operation:\npublic ObservableString concatStreams() { return Observable.concat(emitNumbers(), emitLetters()); } The easiest way to verify, how this operator works, is to create exploratory unit test as follows:\n@Test public void shouldConcatStreams() { // given  ObservableString observable = playground.concatStreams(); ListString expectedValues = Arrays.asList(\"1\",\"2\",\"3\",\"4\",\"a\",\"b\",\"c\",\"d\"); ListString joinedValues = new ArrayList(); // when  observable.blockingSubscribe(s - joinedValues.add(s)); // then  assertThat(joinedValues).isEqualTo(expectedValues); } This operation can be represented graphically as well.\n 1 --- 2 --- 3 --- 4 | a --- b --- c --- d | | concat | \\|/ 1 -- 2 -- 3 -- 4 --- a -- b -- c -- d As we can see one stream is appended to another regardless of the execution time of both streams.\nMerge Merge operator combines multiple Observables into one by merging their emissions. Here we have a similar story, but changed operator:\npublic ObservableString mergeStreams() { return Observable.merge(emitNumbers(), emitLetters()); } We are writing another unit test:\n@Test public void shouldMergeStreams() { // given  ObservableString observable = playground.mergeStreams(); ListString expectedValues = Arrays.asList(\"a\",\"b\",\"c\",\"d\",\"1\",\"2\",\"3\",\"4\"); ListString joinedValues = new ArrayList(); // when  observable.blockingSubscribe(s - joinedValues.add(s)); // then  assertThat(joinedValues).isEqualTo(expectedValues); } Merge operation should look like that:\n 1 --- 2 --- 3 --- 4 | a --- b --- c --- d | | merge | \\|/ a -- b -- c -- d --- 1 -- 2 -- 3 -- 4 This operator doesn’t synchronize the streams and merges them as values are emitted. Numbers are emitted later than letters, so letters are placed in the beginning of the output stream. Try to manipulate marble on the interactive diagram on the reactivex.io website to see how it should work.\nZip The last operator, I’d like to discuss in this article is “Zip” operator. Zip combines the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function. In simple words, it waits until many observables are emitted and then combines them into a pair (or triple Observable, etc. in the case or more Observables). Now, we need to create a function, which will transform our streams and return combined stream.\npublic ObservableString zipStreams() { return Observable.zip(emitNumbers(), emitLetters(), (s1, s2) - String.format(\"(%s,%s)\", s1, s2)); } Next, we can verify it with test as usual:\n@Test public void shouldZipStreams() { // given  ObservableString observable = playground.zipStreams(); ListString expectedValues = Arrays.asList(\"(1,a)\",\"(2,b)\",\"(3,c)\",\"(4,d)\"); ListString joinedValues = new ArrayList(); // when  observable.blockingSubscribe(s - joinedValues.add(s)); // then  assertThat(joinedValues).isEqualTo(expectedValues); } and it can be represented graphically like that:\n 1 --- 2 --- 3 --- 4 | a --- b --- c --- d | | zip | \\|/ (1,a) -- (2,b) --- (3,c) -- (4,d) Now, we have pairs of merged streams.\nSummary Of course, RxJava is complicated library and these methods are not covering all possibilities of merging and combining the Observable streams. Neverhteless, examples in this article are quite basic and may help you to understand how mentioned operators work. After that we can apply the best operator to appropriate situation.\n Reference thread on StackOverflow: http://stackoverflow.com/questions/28843318/android-rxjava-joining-lists\n","wordCount":"638","inLanguage":"en","datePublished":"2017-05-15T20:37:00Z","dateModified":"2017-05-15T20:37:00Z","author":{"@type":"Person","name":"Piotr Wittchen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wittchen.io/posts/joining-lists-of-rxjava-observables/"},"publisher":{"@type":"Organization","name":"Piotr Wittchen","logo":{"@type":"ImageObject","url":"https://wittchen.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wittchen.io/ accesskey=h title="Piotr Wittchen (Alt + H)"><img src=https://wittchen.io/apple-touch-icon.png alt aria-label=logo height=35>Piotr Wittchen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wittchen.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://wittchen.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://wittchen.io/talks/ title=talks><span>talks</span></a></li><li><a href=https://wittchen.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://wittchen.io/contact/ title=contact><span>contact</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wittchen.io/>Home</a>&nbsp;»&nbsp;<a href=https://wittchen.io/posts/>Posts</a></div><h1 class=post-title>Joining lists of RxJava Observables</h1><div class=post-meta><span title="2017-05-15 20:37:00 +0000 UTC">May 15, 2017</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;638 words&nbsp;·&nbsp;Piotr Wittchen&nbsp;|&nbsp;<a href=https://github.com/pwittchen/wittchen.io/blob/master/content/posts/joining-lists-of-rxjava-observables.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>In <a href=https://github.com/ReactiveX/RxJava>RxJava</a> we have a few operators for joining Observables. The most common are:</p><ul><li><a href=http://reactivex.io/documentation/operators/concat.html>concat</a></li><li><a href=http://reactivex.io/documentation/operators/merge.html>merge</a></li><li><a href=http://reactivex.io/documentation/operators/zip.html>zip</a></li></ul><p>Take a look at the documentation in these links. It has <strong>interactive marble diagrams</strong> showing how the operators work on the streams. You can move marbles along the lines and see how the output stream changes. It really helps to understand how it works. Code snippets in this article are based on RxJava 2.1.0 with JUnit 4.12 and Google Truth 0.32 for unit tests. Let&rsquo;s say, we have the following Observables:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>Observable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=nf>emitNumbers</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>Observable</span><span class=o>.</span><span class=na>fromArray</span><span class=o>(</span><span class=s>&#34;1&#34;</span><span class=o>,</span> <span class=s>&#34;2&#34;</span><span class=o>,</span> <span class=s>&#34;3&#34;</span><span class=o>,</span> <span class=s>&#34;4&#34;</span><span class=o>).</span><span class=na>delay</span><span class=o>(</span><span class=n>1</span><span class=o>,</span> <span class=n>TimeUnit</span><span class=o>.</span><span class=na>SECONDS</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>Observable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=nf>emitLetters</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>Observable</span><span class=o>.</span><span class=na>fromArray</span><span class=o>(</span><span class=s>&#34;a&#34;</span><span class=o>,</span> <span class=s>&#34;b&#34;</span><span class=o>,</span> <span class=s>&#34;c&#34;</span><span class=o>,</span> <span class=s>&#34;d&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>We can merge them in the different ways.</p><h2 id=concathttpreactivexiodocumentationoperatorsconcathtml><a href=http://reactivex.io/documentation/operators/concat.html>Concat</a><a hidden class=anchor aria-hidden=true href=#concathttpreactivexiodocumentationoperatorsconcathtml>#</a></h2><p>Concat operator <em>emits the emissions from two or more Observables without interleaving them</em>. We can perform the following operation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>Observable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=nf>concatStreams</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>Observable</span><span class=o>.</span><span class=na>concat</span><span class=o>(</span><span class=n>emitNumbers</span><span class=o>(),</span> <span class=n>emitLetters</span><span class=o>());</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>The easiest way to verify, how this operator works, is to create exploratory unit test as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>shouldConcatStreams</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// given
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Observable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>observable</span> <span class=o>=</span> <span class=n>playground</span><span class=o>.</span><span class=na>concatStreams</span><span class=o>();</span>
</span></span><span class=line><span class=cl>  <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>expectedValues</span> <span class=o>=</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=s>&#34;1&#34;</span><span class=o>,</span><span class=s>&#34;2&#34;</span><span class=o>,</span><span class=s>&#34;3&#34;</span><span class=o>,</span><span class=s>&#34;4&#34;</span><span class=o>,</span><span class=s>&#34;a&#34;</span><span class=o>,</span><span class=s>&#34;b&#34;</span><span class=o>,</span><span class=s>&#34;c&#34;</span><span class=o>,</span><span class=s>&#34;d&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>joinedValues</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// when
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>observable</span><span class=o>.</span><span class=na>blockingSubscribe</span><span class=o>(</span><span class=n>s</span> <span class=o>-&gt;</span> <span class=n>joinedValues</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>s</span><span class=o>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// then
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>assertThat</span><span class=o>(</span><span class=n>joinedValues</span><span class=o>).</span><span class=na>isEqualTo</span><span class=o>(</span><span class=n>expectedValues</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>This operation can be represented graphically as well.</p><pre tabindex=0><code>         1 --- 2 --- 3 --- 4
                  |
         a --- b --- c --- d
                  |
                  |
                concat
                  |
                 \|/
1 -- 2 -- 3 -- 4 --- a -- b -- c -- d
</code></pre><p>As we can see one stream is appended to another regardless of the execution time of both streams.</p><h2 id=mergehttpreactivexiodocumentationoperatorsmergehtml><a href=http://reactivex.io/documentation/operators/merge.html>Merge</a><a hidden class=anchor aria-hidden=true href=#mergehttpreactivexiodocumentationoperatorsmergehtml>#</a></h2><p>Merge operator <em>combines multiple Observables into one by merging their emissions</em>. Here we have a similar story, but changed operator:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>Observable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=nf>mergeStreams</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>Observable</span><span class=o>.</span><span class=na>merge</span><span class=o>(</span><span class=n>emitNumbers</span><span class=o>(),</span> <span class=n>emitLetters</span><span class=o>());</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>We are writing another unit test:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>shouldMergeStreams</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// given
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Observable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>observable</span> <span class=o>=</span> <span class=n>playground</span><span class=o>.</span><span class=na>mergeStreams</span><span class=o>();</span>
</span></span><span class=line><span class=cl>  <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>expectedValues</span> <span class=o>=</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=s>&#34;a&#34;</span><span class=o>,</span><span class=s>&#34;b&#34;</span><span class=o>,</span><span class=s>&#34;c&#34;</span><span class=o>,</span><span class=s>&#34;d&#34;</span><span class=o>,</span><span class=s>&#34;1&#34;</span><span class=o>,</span><span class=s>&#34;2&#34;</span><span class=o>,</span><span class=s>&#34;3&#34;</span><span class=o>,</span><span class=s>&#34;4&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>joinedValues</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// when
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>observable</span><span class=o>.</span><span class=na>blockingSubscribe</span><span class=o>(</span><span class=n>s</span> <span class=o>-&gt;</span> <span class=n>joinedValues</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>s</span><span class=o>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// then
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>assertThat</span><span class=o>(</span><span class=n>joinedValues</span><span class=o>).</span><span class=na>isEqualTo</span><span class=o>(</span><span class=n>expectedValues</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>Merge operation should look like that:</p><pre tabindex=0><code>         1 --- 2 --- 3 --- 4
                  |
         a --- b --- c --- d
                  |
                  |
                merge
                  |
                 \|/
a -- b -- c -- d --- 1 -- 2 -- 3 -- 4
</code></pre><p>This operator doesn&rsquo;t synchronize the streams and merges them as values are emitted. Numbers are emitted later than letters, so letters are placed in the beginning of the output stream. Try to manipulate marble on the interactive diagram on the <a href=http://reactivex.io>reactivex.io</a> website to see how it should work.</p><h2 id=ziphttpreactivexiodocumentationoperatorsziphtml><a href=http://reactivex.io/documentation/operators/zip.html>Zip</a><a hidden class=anchor aria-hidden=true href=#ziphttpreactivexiodocumentationoperatorsziphtml>#</a></h2><p>The last operator, I&rsquo;d like to discuss in this article is &ldquo;Zip&rdquo; operator. Zip <em>combines the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function</em>. In simple words, it waits until many observables are emitted and then combines them into a pair (or triple Observable, etc. in the case or more Observables). Now, we need to create a function, which will transform our streams and return combined stream.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>Observable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=nf>zipStreams</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>Observable</span><span class=o>.</span><span class=na>zip</span><span class=o>(</span><span class=n>emitNumbers</span><span class=o>(),</span> <span class=n>emitLetters</span><span class=o>(),</span>
</span></span><span class=line><span class=cl>      <span class=o>(</span><span class=n>s1</span><span class=o>,</span> <span class=n>s2</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>String</span><span class=o>.</span><span class=na>format</span><span class=o>(</span><span class=s>&#34;(%s,%s)&#34;</span><span class=o>,</span> <span class=n>s1</span><span class=o>,</span> <span class=n>s2</span><span class=o>));</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>Next, we can verify it with test as usual:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>shouldZipStreams</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// given
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Observable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>observable</span> <span class=o>=</span> <span class=n>playground</span><span class=o>.</span><span class=na>zipStreams</span><span class=o>();</span>
</span></span><span class=line><span class=cl>  <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>expectedValues</span> <span class=o>=</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=s>&#34;(1,a)&#34;</span><span class=o>,</span><span class=s>&#34;(2,b)&#34;</span><span class=o>,</span><span class=s>&#34;(3,c)&#34;</span><span class=o>,</span><span class=s>&#34;(4,d)&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>joinedValues</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// when
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>observable</span><span class=o>.</span><span class=na>blockingSubscribe</span><span class=o>(</span><span class=n>s</span> <span class=o>-&gt;</span> <span class=n>joinedValues</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>s</span><span class=o>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// then
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>assertThat</span><span class=o>(</span><span class=n>joinedValues</span><span class=o>).</span><span class=na>isEqualTo</span><span class=o>(</span><span class=n>expectedValues</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>and it can be represented graphically like that:</p><pre tabindex=0><code>        1 --- 2 --- 3 --- 4
                 |
        a --- b --- c --- d
                 |
                 |
                zip
                 |
                \|/
 (1,a) -- (2,b) --- (3,c) -- (4,d)
</code></pre><p>Now, we have pairs of merged streams.</p><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>Of course, RxJava is complicated library and these methods are not covering all possibilities of merging and combining the Observable streams. Neverhteless, examples in this article are quite basic and may help you to understand how mentioned operators work. After that we can apply the best operator to appropriate situation.</p><hr><p>Reference thread on StackOverflow: <a href=http://stackoverflow.com/questions/28843318/android-rxjava-joining-lists>http://stackoverflow.com/questions/28843318/android-rxjava-joining-lists</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wittchen.io/tags/java/>java</a></li><li><a href=https://wittchen.io/tags/rxjava/>rxjava</a></li></ul><nav class=paginav><a class=prev href=https://wittchen.io/posts/prefser-207/><span class=title>« Prev</span><br><span>Releasing Prefser v. 2.0.7</span></a>
<a class=next href=https://wittchen.io/posts/emitting-different-rxjava-observables-depending-on-the-condition-with-flatmap/><span class=title>Next »</span><br><span>Emitting different observables conditionally</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://wittchen.io/>Piotr Wittchen</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerHTML="copy";function s(){e.innerHTML="copied!",setTimeout(()=>{e.innerHTML="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>