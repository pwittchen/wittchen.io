{"title":"Different ways of squashing commits","slug":"squashing-commits","date":"2018-07-21T09:21:54.000Z","updated":"2019-07-03T22:51:02.813Z","comments":true,"path":"api/articles/squashing-commits.json","excerpt":null,"covers":null,"content":"<p>While creating a Pull Requests it’s good to squash all of our intermediate commits into one to avoid clutter in the git log, simplify analysis and allow for simple code revert when necessary. </p>\n<h2 id=\"Solution-1\"><a href=\"#Solution-1\" class=\"headerlink\" title=\"Solution #1\"></a>Solution #1</h2><p>Some time ago I’ve found project <a href=\"http://rebaseandsqua.sh/\" target=\"_blank\" rel=\"noopener\">http://rebaseandsqua.sh/</a> made by Jake Wharton. It’s really useful, handy and allows us to rebase and squash commits quite easily. </p>\n<p>We can just call:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl rebaseandsqua.sh | sh</span><br></pre></td></tr></table></figure>\n\n<p>then edit our commit messages and push the changes.</p>\n<h2 id=\"Solution-2\"><a href=\"#Solution-2\" class=\"headerlink\" title=\"Solution #2\"></a>Solution #2</h2><p>If we want to understand this process and do it manually instead of delegating it to the script from the web, we should perform the following steps:</p>\n<p>First, we need to decide how many commits, we want to squash. Let’s say 3:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure>\n\n<p>We should see something like this in our editor of choice:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pick 48d7c25 adding link to vim-jdb plugin in README.md</span><br><span class=\"line\">pick 97376b4 Update README.md</span><br><span class=\"line\">pick a92b5bf adding squash alias to .gitconfig</span><br></pre></td></tr></table></figure>\n\n<p>Next, we can decide, which commits we want to squash:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pick 48d7c25 adding link to vim-jdb plugin in README.md</span><br><span class=\"line\">squash 97376b4 Update README.md</span><br><span class=\"line\">squash a92b5bf adding squash alias to .gitconfig</span><br></pre></td></tr></table></figure>\n\n<p>When, we save it, all of our commits will be squashed into one containing all commit messages.<br>We can now edit this message with command:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --amend</span><br></pre></td></tr></table></figure>\n\n<p>You can read more about it in the <a href=\"https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History\" target=\"_blank\" rel=\"noopener\">official Git documentation</a>.</p>\n<h2 id=\"Solution-3\"><a href=\"#Solution-3\" class=\"headerlink\" title=\"Solution #3\"></a>Solution #3</h2><p>Some time ago I created a git alias for myself for merging last commits in <code>.gitconfig</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">merge-local-commits = !sh -c &apos;git reset --soft HEAD~$1&apos; -</span><br></pre></td></tr></table></figure>\n\n<p>We can invoke it with e.g.:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge-local-commits 3</span><br></pre></td></tr></table></figure>\n\n<p>It works pretty fine, but we need to remember how many commits we want to merge, type a commit message and perform commit again.</p>\n<h2 id=\"Solution-4\"><a href=\"#Solution-4\" class=\"headerlink\" title=\"Solution #4\"></a>Solution #4</h2><p>Recently I’ve found another solution to this problem represented with the following alias:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">squash = &quot;!f()&#123; git reset --soft HEAD~$&#123;1&#125; &amp;&amp; git commit --edit -m\\&quot;$(git log --format=%B --reverse HEAD..HEAD@&#123;1&#125;)\\&quot;;   &#125;;f&quot;</span><br></pre></td></tr></table></figure>\n\n<p>It’s doing the same thing as previous alias, but it preserves all the commit messages. Thanks to that, we can keep all of our commit messages or delete them and leave just one, which is the most relevant for the given change. When we want to “squash” 3 commits, we can just type:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git squash 3</span><br></pre></td></tr></table></figure>\n\n<p>and we are ready to override all the intermediate commits with the single commit for the Pull Request:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -f</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>As you can see, there are many ways to squash commits into one. Probably there are another solutions, which are not described in this article. You can pratice them in some kind of “dummy” repo and then, when you’ll feel comfortable with it, introduce it in your daily workflow. I hope, now you won’t be afraid of squashing your commits :-).</p>\n","more":"<p>While creating a Pull Requests it’s good to squash all of our intermediate commits into one to avoid clutter in the git log, simplify analysis and allow for simple code revert when necessary. </p>\n<h2 id=\"Solution-1\"><a href=\"#Solution-1\" class=\"headerlink\" title=\"Solution #1\"></a>Solution #1</h2><p>Some time ago I’ve found project <a href=\"http://rebaseandsqua.sh/\" target=\"_blank\" rel=\"noopener\">http://rebaseandsqua.sh/</a> made by Jake Wharton. It’s really useful, handy and allows us to rebase and squash commits quite easily. </p>\n<p>We can just call:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl rebaseandsqua.sh | sh</span><br></pre></td></tr></table></figure>\n\n<p>then edit our commit messages and push the changes.</p>\n<h2 id=\"Solution-2\"><a href=\"#Solution-2\" class=\"headerlink\" title=\"Solution #2\"></a>Solution #2</h2><p>If we want to understand this process and do it manually instead of delegating it to the script from the web, we should perform the following steps:</p>\n<p>First, we need to decide how many commits, we want to squash. Let’s say 3:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure>\n\n<p>We should see something like this in our editor of choice:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pick 48d7c25 adding link to vim-jdb plugin in README.md</span><br><span class=\"line\">pick 97376b4 Update README.md</span><br><span class=\"line\">pick a92b5bf adding squash alias to .gitconfig</span><br></pre></td></tr></table></figure>\n\n<p>Next, we can decide, which commits we want to squash:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pick 48d7c25 adding link to vim-jdb plugin in README.md</span><br><span class=\"line\">squash 97376b4 Update README.md</span><br><span class=\"line\">squash a92b5bf adding squash alias to .gitconfig</span><br></pre></td></tr></table></figure>\n\n<p>When, we save it, all of our commits will be squashed into one containing all commit messages.<br>We can now edit this message with command:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --amend</span><br></pre></td></tr></table></figure>\n\n<p>You can read more about it in the <a href=\"https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History\" target=\"_blank\" rel=\"noopener\">official Git documentation</a>.</p>\n<h2 id=\"Solution-3\"><a href=\"#Solution-3\" class=\"headerlink\" title=\"Solution #3\"></a>Solution #3</h2><p>Some time ago I created a git alias for myself for merging last commits in <code>.gitconfig</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">merge-local-commits = !sh -c &apos;git reset --soft HEAD~$1&apos; -</span><br></pre></td></tr></table></figure>\n\n<p>We can invoke it with e.g.:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge-local-commits 3</span><br></pre></td></tr></table></figure>\n\n<p>It works pretty fine, but we need to remember how many commits we want to merge, type a commit message and perform commit again.</p>\n<h2 id=\"Solution-4\"><a href=\"#Solution-4\" class=\"headerlink\" title=\"Solution #4\"></a>Solution #4</h2><p>Recently I’ve found another solution to this problem represented with the following alias:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">squash = &quot;!f()&#123; git reset --soft HEAD~$&#123;1&#125; &amp;&amp; git commit --edit -m\\&quot;$(git log --format=%B --reverse HEAD..HEAD@&#123;1&#125;)\\&quot;;   &#125;;f&quot;</span><br></pre></td></tr></table></figure>\n\n<p>It’s doing the same thing as previous alias, but it preserves all the commit messages. Thanks to that, we can keep all of our commit messages or delete them and leave just one, which is the most relevant for the given change. When we want to “squash” 3 commits, we can just type:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git squash 3</span><br></pre></td></tr></table></figure>\n\n<p>and we are ready to override all the intermediate commits with the single commit for the Pull Request:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -f</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>As you can see, there are many ways to squash commits into one. Probably there are another solutions, which are not described in this article. You can pratice them in some kind of “dummy” repo and then, when you’ll feel comfortable with it, introduce it in your daily workflow. I hope, now you won’t be afraid of squashing your commits :-).</p>\n","categories":[],"tags":[{"name":"git","path":"api/tags/git.json"}]}