{"title":"New reactive data types in RxJava2","slug":"new-reactive-data-types-in-rxjava2","date":"2017-05-31T15:49:00.000Z","updated":"2019-07-03T22:51:02.813Z","comments":true,"path":"api/articles/new-reactive-data-types-in-rxjava2.json","excerpt":null,"covers":["/images/posts/2017/new-reactive-data-types-in-rxjava2/observable-644x319.png","/images/posts/2017/new-reactive-data-types-in-rxjava2/single-644x303.png","/images/posts/2017/new-reactive-data-types-in-rxjava2/maybe.png"],"content":"<h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><p>I’m still exploring reactive programming world and RxJava library. Recently, I’ve migrated a few of my open-source libraries from RxJava1 to RxJava2 and written yet another project in RxJava2 from the beginning. Nevertheless, I’m still learning this library and its concept. It’s very wide topic. In RxJava1 we simply had one reactive data type called <code>Observable</code>. In RxJava2, we have more data types like <code>Observable</code>, <code>Flowable</code>, <code>Single</code>, <code>Maybe</code> &amp; <code>Completable</code>. In this article, I’ll briefly explain their purpose and tell you when to use which. The general idea behind these types is code semantics. We should tell consumer of our code, what he or she can expect from our API. Introducing more reactive data types can increase readability and stability of our code base.</p>\n<h2 id=\"Observable\"><a href=\"#Observable\" class=\"headerlink\" title=\"Observable\"></a><a href=\"http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html\" target=\"_blank\" rel=\"noopener\">Observable</a></h2><p><code>Observable</code> is basically the same Reactive type, we had in RxJava1. <strong>It doesn’t have <a href=\"https://github.com/ReactiveX/RxJava/wiki/What' target=\"_blank\" rel=\"noopener\"s-different-in-2.0#backpressure\">backpressure</a> support</strong>. We should use <code>Observable</code>, when:</p>\n<ul>\n<li>our data source emits less than 1000 items, so there’s practically no chance of occurring <code>OutOfMemoryException</code></li>\n<li>we are working with GUI events, which usually don’t occurs very often and don’t have to be backpressured</li>\n<li>we are working with synchronous code on legacy JVM like Java 1.6 and we want to have streams features like in Java 8</li>\n</ul>\n<p><img src=\"/images/posts/2017/new-reactive-data-types-in-rxjava2/observable-644x319.png\" alt=\"Observable\"></p>\n<h2 id=\"Flowable\"><a href=\"#Flowable\" class=\"headerlink\" title=\"Flowable\"></a><a href=\"http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html\" target=\"_blank\" rel=\"noopener\">Flowable</a></h2><p><code>Flowable</code> type has very similar semantics to <code>Observable</code>. We can operate on <code>Flowable</code> streams with map, flatmap, filter, etc. in the same way as on the <code>Observable</code> type. The main difference is <strong><a href=\"https://github.com/ReactiveX/RxJava/wiki/What' target=\"_blank\" rel=\"noopener\"s-different-in-2.0#backpressure\">backpressure</a> support</strong>. We should use <code>Flowable</code> when we are:</p>\n<ul>\n<li>dealing with 10k+ elements in a stream</li>\n<li>dealing with frequent events (e.g. sensors readings)</li>\n<li>reading/parsing files from disk</li>\n<li>reading values from database through JDBC</li>\n<li>using network/streaming I/O</li>\n<li>reading/writing to many blocking or pull-based data sources</li>\n</ul>\n<p>To learn more, read note about <a href=\"https://github.com/ReactiveX/RxJava/wiki/What' target=\"_blank\" rel=\"noopener\"s-different-in-2.0#observable-and-flowable\">Observable vs. Flowable</a> on wiki of RxJava2 on GitHub.</p>\n<h2 id=\"Single\"><a href=\"#Single\" class=\"headerlink\" title=\"Single\"></a><a href=\"http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Single.html\" target=\"_blank\" rel=\"noopener\">Single</a></h2><p><code>Single</code> reactive type has been redesigned from scratch in RxJava 2. It’s designed to handle just one event in an asynchronous manner. Good application of this type is single HTTP request when we expect just one response or error and nothing else. It can emit on <code>onSuccess</code> (single value) or <code>onError</code> event (error). </p>\n<p><img src=\"/images/posts/2017/new-reactive-data-types-in-rxjava2/single-644x303.png\" alt=\"Single\"></p>\n<h2 id=\"Maybe\"><a href=\"#Maybe\" class=\"headerlink\" title=\"Maybe\"></a><a href=\"http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Maybe.html\" target=\"_blank\" rel=\"noopener\">Maybe</a></h2><p><code>Maybe</code> represents a deferred computation and emission of a maybe value or exception. <code>Maybe</code> is a wrapper around an operation/event that may have either:</p>\n<ul>\n<li>A single result</li>\n<li>Error</li>\n<li>No result</li>\n</ul>\n<p>Just take a look at the scheme. The interface of the main consumer of this type have the following methods: <code>onSuccess</code>, <code>onError</code>, <code>onComplete</code>. Conceptually, <code>Maybe</code> is a union of <code>Single</code> and <code>Completable</code> providing the means to capture an emission pattern where there could be 0 or 1 item or an error signaled by some reactive source. </p>\n<p><img src=\"/images/posts/2017/new-reactive-data-types-in-rxjava2/maybe.png\" alt=\"Maybe\"></p>\n<h2 id=\"Completable\"><a href=\"#Completable\" class=\"headerlink\" title=\"Completable\"></a><a href=\"http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Completable.html\" target=\"_blank\" rel=\"noopener\">Completable</a></h2><p><code>Completable</code> type can be used when we have an <code>Observable</code> that <strong>we don’t care about the value resulted from the operation</strong> (result is void). It handles only <code>onComplete</code> and <code>onError</code> events. Conceptually, <code>Maybe</code> is a union of <code>Single</code> and <code>Completable</code> providing the means to capture an emission pattern where there could be 0 or 1 item or an error signalled by some reactive source. Read more about <code>Maybe</code> type on <a href=\"https://github.com/ReactiveX/RxJava/wiki/What%27s-different-in-2.0#maybe\" target=\"_blank\" rel=\"noopener\">RxJava wiki</a>.</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>As we can see, RxJava2 gives us new types, which can help explain our intentions more clearly. We can adjust concrete type to the specific situation. In addition, we can use backpressure for the data sources, which emit a lot of elements to make our projects more robust and stable. Last, but not least RxJava2 is compatible with <a href=\"http://reactive-streams.org\" target=\"_blank\" rel=\"noopener\">Reactive Streams</a> API, which is going to be part of the Java 9 specification.</p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><ul>\n<li><a href=\"http://reactivex.io/RxJava/2.x/javadoc/\" target=\"_blank\" rel=\"noopener\">JavaDoc for RxJava2</a></li>\n<li><a href=\"https://github.com/ReactiveX/RxJava/wiki/What' target=\"_blank\" rel=\"noopener\"s-different-in-2.0\">What’s diffferent in 2.0?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/42757924/what-is-the-difference-between-observable-completable-and-single-in-rxjava\" target=\"_blank\" rel=\"noopener\">StackOverflow Thread: What is the difference between Observable, Completable and Single in RxJava?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/40439579/whats-the-difference-between-rxjava2s-maybe-and-optional\" target=\"_blank\" rel=\"noopener\">StackOverflow Thread: What’s the difference between RxJava2’s Maybe and Optional?</a></li>\n<li><a href=\"https://android.jlelse.eu/making-your-rxjava-intentions-clearer-with-single-and-completable-f064d98d53a8\" target=\"_blank\" rel=\"noopener\">Clearer RxJava intentions with Single and Completable</a></li>\n<li><a href=\"http://akarnokd.blogspot.com/\" target=\"_blank\" rel=\"noopener\">Blog of Akarnokd (one of the main RxJava contributors)</a></li>\n<li><a href=\"https://github.com/ReactiveX/RxJava\" target=\"_blank\" rel=\"noopener\">RxJava GitHub repository</a></li>\n<li><a href=\"http://reactivex.io/\" target=\"_blank\" rel=\"noopener\">ReactiveX</a></li>\n<li><a href=\"http://shop.oreilly.com/product/0636920042228.do\" target=\"_blank\" rel=\"noopener\">Reactive Programming with RxJava (O’Reilly Media Book)</a></li>\n<li><a href=\"http://www.reactive-streams.org/\" target=\"_blank\" rel=\"noopener\">Reactive Streams</a></li>\n<li><a href=\"http://www.reactivemanifesto.org/\" target=\"_blank\" rel=\"noopener\">Reactive Manifesto</a></li>\n</ul>\n","more":"<h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><p>I’m still exploring reactive programming world and RxJava library. Recently, I’ve migrated a few of my open-source libraries from RxJava1 to RxJava2 and written yet another project in RxJava2 from the beginning. Nevertheless, I’m still learning this library and its concept. It’s very wide topic. In RxJava1 we simply had one reactive data type called <code>Observable</code>. In RxJava2, we have more data types like <code>Observable</code>, <code>Flowable</code>, <code>Single</code>, <code>Maybe</code> &amp; <code>Completable</code>. In this article, I’ll briefly explain their purpose and tell you when to use which. The general idea behind these types is code semantics. We should tell consumer of our code, what he or she can expect from our API. Introducing more reactive data types can increase readability and stability of our code base.</p>\n<h2 id=\"Observable\"><a href=\"#Observable\" class=\"headerlink\" title=\"Observable\"></a><a href=\"http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html\" target=\"_blank\" rel=\"noopener\">Observable</a></h2><p><code>Observable</code> is basically the same Reactive type, we had in RxJava1. <strong>It doesn’t have <a href=\"https://github.com/ReactiveX/RxJava/wiki/What' target=\"_blank\" rel=\"noopener\"s-different-in-2.0#backpressure\">backpressure</a> support</strong>. We should use <code>Observable</code>, when:</p>\n<ul>\n<li>our data source emits less than 1000 items, so there’s practically no chance of occurring <code>OutOfMemoryException</code></li>\n<li>we are working with GUI events, which usually don’t occurs very often and don’t have to be backpressured</li>\n<li>we are working with synchronous code on legacy JVM like Java 1.6 and we want to have streams features like in Java 8</li>\n</ul>\n<p><img src=\"/images/posts/2017/new-reactive-data-types-in-rxjava2/observable-644x319.png\" alt=\"Observable\"></p>\n<h2 id=\"Flowable\"><a href=\"#Flowable\" class=\"headerlink\" title=\"Flowable\"></a><a href=\"http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html\" target=\"_blank\" rel=\"noopener\">Flowable</a></h2><p><code>Flowable</code> type has very similar semantics to <code>Observable</code>. We can operate on <code>Flowable</code> streams with map, flatmap, filter, etc. in the same way as on the <code>Observable</code> type. The main difference is <strong><a href=\"https://github.com/ReactiveX/RxJava/wiki/What' target=\"_blank\" rel=\"noopener\"s-different-in-2.0#backpressure\">backpressure</a> support</strong>. We should use <code>Flowable</code> when we are:</p>\n<ul>\n<li>dealing with 10k+ elements in a stream</li>\n<li>dealing with frequent events (e.g. sensors readings)</li>\n<li>reading/parsing files from disk</li>\n<li>reading values from database through JDBC</li>\n<li>using network/streaming I/O</li>\n<li>reading/writing to many blocking or pull-based data sources</li>\n</ul>\n<p>To learn more, read note about <a href=\"https://github.com/ReactiveX/RxJava/wiki/What' target=\"_blank\" rel=\"noopener\"s-different-in-2.0#observable-and-flowable\">Observable vs. Flowable</a> on wiki of RxJava2 on GitHub.</p>\n<h2 id=\"Single\"><a href=\"#Single\" class=\"headerlink\" title=\"Single\"></a><a href=\"http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Single.html\" target=\"_blank\" rel=\"noopener\">Single</a></h2><p><code>Single</code> reactive type has been redesigned from scratch in RxJava 2. It’s designed to handle just one event in an asynchronous manner. Good application of this type is single HTTP request when we expect just one response or error and nothing else. It can emit on <code>onSuccess</code> (single value) or <code>onError</code> event (error). </p>\n<p><img src=\"/images/posts/2017/new-reactive-data-types-in-rxjava2/single-644x303.png\" alt=\"Single\"></p>\n<h2 id=\"Maybe\"><a href=\"#Maybe\" class=\"headerlink\" title=\"Maybe\"></a><a href=\"http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Maybe.html\" target=\"_blank\" rel=\"noopener\">Maybe</a></h2><p><code>Maybe</code> represents a deferred computation and emission of a maybe value or exception. <code>Maybe</code> is a wrapper around an operation/event that may have either:</p>\n<ul>\n<li>A single result</li>\n<li>Error</li>\n<li>No result</li>\n</ul>\n<p>Just take a look at the scheme. The interface of the main consumer of this type have the following methods: <code>onSuccess</code>, <code>onError</code>, <code>onComplete</code>. Conceptually, <code>Maybe</code> is a union of <code>Single</code> and <code>Completable</code> providing the means to capture an emission pattern where there could be 0 or 1 item or an error signaled by some reactive source. </p>\n<p><img src=\"/images/posts/2017/new-reactive-data-types-in-rxjava2/maybe.png\" alt=\"Maybe\"></p>\n<h2 id=\"Completable\"><a href=\"#Completable\" class=\"headerlink\" title=\"Completable\"></a><a href=\"http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Completable.html\" target=\"_blank\" rel=\"noopener\">Completable</a></h2><p><code>Completable</code> type can be used when we have an <code>Observable</code> that <strong>we don’t care about the value resulted from the operation</strong> (result is void). It handles only <code>onComplete</code> and <code>onError</code> events. Conceptually, <code>Maybe</code> is a union of <code>Single</code> and <code>Completable</code> providing the means to capture an emission pattern where there could be 0 or 1 item or an error signalled by some reactive source. Read more about <code>Maybe</code> type on <a href=\"https://github.com/ReactiveX/RxJava/wiki/What%27s-different-in-2.0#maybe\" target=\"_blank\" rel=\"noopener\">RxJava wiki</a>.</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>As we can see, RxJava2 gives us new types, which can help explain our intentions more clearly. We can adjust concrete type to the specific situation. In addition, we can use backpressure for the data sources, which emit a lot of elements to make our projects more robust and stable. Last, but not least RxJava2 is compatible with <a href=\"http://reactive-streams.org\" target=\"_blank\" rel=\"noopener\">Reactive Streams</a> API, which is going to be part of the Java 9 specification.</p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><ul>\n<li><a href=\"http://reactivex.io/RxJava/2.x/javadoc/\" target=\"_blank\" rel=\"noopener\">JavaDoc for RxJava2</a></li>\n<li><a href=\"https://github.com/ReactiveX/RxJava/wiki/What' target=\"_blank\" rel=\"noopener\"s-different-in-2.0\">What’s diffferent in 2.0?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/42757924/what-is-the-difference-between-observable-completable-and-single-in-rxjava\" target=\"_blank\" rel=\"noopener\">StackOverflow Thread: What is the difference between Observable, Completable and Single in RxJava?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/40439579/whats-the-difference-between-rxjava2s-maybe-and-optional\" target=\"_blank\" rel=\"noopener\">StackOverflow Thread: What’s the difference between RxJava2’s Maybe and Optional?</a></li>\n<li><a href=\"https://android.jlelse.eu/making-your-rxjava-intentions-clearer-with-single-and-completable-f064d98d53a8\" target=\"_blank\" rel=\"noopener\">Clearer RxJava intentions with Single and Completable</a></li>\n<li><a href=\"http://akarnokd.blogspot.com/\" target=\"_blank\" rel=\"noopener\">Blog of Akarnokd (one of the main RxJava contributors)</a></li>\n<li><a href=\"https://github.com/ReactiveX/RxJava\" target=\"_blank\" rel=\"noopener\">RxJava GitHub repository</a></li>\n<li><a href=\"http://reactivex.io/\" target=\"_blank\" rel=\"noopener\">ReactiveX</a></li>\n<li><a href=\"http://shop.oreilly.com/product/0636920042228.do\" target=\"_blank\" rel=\"noopener\">Reactive Programming with RxJava (O’Reilly Media Book)</a></li>\n<li><a href=\"http://www.reactive-streams.org/\" target=\"_blank\" rel=\"noopener\">Reactive Streams</a></li>\n<li><a href=\"http://www.reactivemanifesto.org/\" target=\"_blank\" rel=\"noopener\">Reactive Manifesto</a></li>\n</ul>\n","categories":[],"tags":[{"name":"java","path":"api/tags/java.json"},{"name":"rxjava","path":"api/tags/rxjava.json"}]}