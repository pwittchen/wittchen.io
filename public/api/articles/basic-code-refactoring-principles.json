{"title":"Basic code refactoring principles","slug":"basic-code-refactoring-principles","date":"2017-05-05T21:29:00.000Z","updated":"2019-07-03T22:51:02.810Z","comments":true,"path":"api/articles/basic-code-refactoring-principles.json","excerpt":null,"covers":null,"content":"<h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><p>I’ve recently read a book about <em>Test Driven Development</em> by Kent Beck. It’s really good, presents the importance of the TDD and shows how to make a life of the software developer easier. In the TDD we follow <em>red-green-refactor</em> process in which we create a failing unit test, then we fix it and refactor it to make code-base better. There’s no golden rule when to refactor or how to refactor code and each project is different, but there are a few principles we may follow when we want to improve our projects through refactoring.</p>\n<h2 id=\"Finding-similarities-and-duplications\"><a href=\"#Finding-similarities-and-duplications\" class=\"headerlink\" title=\"Finding similarities and duplications\"></a>Finding similarities and duplications</h2><p>One of the common <em>code smells</em> is duplication. We should search for the following patterns:</p>\n<ul>\n<li>Two similar loops » try to merge them into one loop</li>\n<li>Two similar instructions inside conditional statements » try to unify operations and get rid of the “if” statement</li>\n<li>Two similar methods » try to unify them and remove one of them</li>\n<li>Two similar classes » try to unify them and remove one of them</li>\n<li>and so on…</li>\n</ul>\n<p>Perform these operations carefully. If something goes wrong, go one step backward. Sometimes it may be impossible to remove all duplications.</p>\n<h2 id=\"Isolating-changes\"><a href=\"#Isolating-changes\" class=\"headerlink\" title=\"Isolating changes\"></a>Isolating changes</h2><p>Before we start performing changes, it’s good to isolate a piece of code. We can move it e.g. to separate method, perform changes and then inline our method. That could help us avoid breaking the whole system.</p>\n<h2 id=\"Data-migration\"><a href=\"#Data-migration\" class=\"headerlink\" title=\"Data migration\"></a>Data migration</h2><p>If we want to change the meaning of the data, we can temporarily duplicate them, perform changes, update interfaces and then remove original code.</p>\n<h2 id=\"Method-extraction\"><a href=\"#Method-extraction\" class=\"headerlink\" title=\"Method extraction\"></a>Method extraction</h2><p>If a method in our class is too big (according to <em>Clean Code</em>, “too big” is longer than 20 lines), we should find code doing specialized mini-task and extract part of it to a separate method. In IntelliJ IDEA we can use <code>Ctrl+Alt+M</code> shortcut or <code>⌘+Alt+M</code> on Mac for that.</p>\n<h2 id=\"Method-inlining\"><a href=\"#Method-inlining\" class=\"headerlink\" title=\"Method inlining\"></a>Method inlining</h2><p>Sometimes, we’re extracting too many pieces of code to separate methods, what may decrease code readability. If the code inside the method is really simple, so it could be written in a single line or optionally in two lines, we may think about inlining this method. To do so, we should remove method and place code directly in the place where it’s called. To perform inlining in IntelliJ, we can use <code>Ctrl+Alt+N</code> shortcut or <code>⌘+Alt+N</code> on Mac.</p>\n<h2 id=\"Interface-extraction\"><a href=\"#Interface-extraction\" class=\"headerlink\" title=\"Interface extraction\"></a>Interface extraction</h2><p>When we want to create additional implementations of the operations, which already exists in our code-base, we may extract these operations into the interface. IntelliJ IDEA also has support for that. I’m not sure if there’s a shortcut, but you can use <code>Ctrl+Shit+A</code> shortcut or <code>⌘+Shift+A</code> on Mac to open window with operation search and then type <em>“extract interface”</em>. It should work.</p>\n<h2 id=\"Moving-method\"><a href=\"#Moving-method\" class=\"headerlink\" title=\"Moving method\"></a>Moving method</h2><p>It may happen, that our class or interface is becoming too big or it has methods, which are not directly related to this class. In such case, we may simply move one method or a few methods to another, more appropriate class or create a separate class or interface for them.</p>\n<h2 id=\"Object-method\"><a href=\"#Object-method\" class=\"headerlink\" title=\"Object-method\"></a>Object-method</h2><p>We may encounter a situation when a specific method has too many parameters. In such case, we may consider creating Object-method. It’s some kind of data class, which contains attributes the same as method parameters. It will help us to pass data in our system in a more readable way. We can also connect this solution with a Builder software design pattern.</p>\n<h2 id=\"Adding-parameter\"><a href=\"#Adding-parameter\" class=\"headerlink\" title=\"Adding parameter\"></a>Adding parameter</h2><p>During the time, the business logic of our system is getting bigger and one of our methods need to be extended. In such case, we can add another parameter to it. We may also consider creating another, similar method with just one more parameter. When we’re providing API or framework for other developers, we have to remember about proper “deprecated” annotations.</p>\n<h2 id=\"Moving-parameter-from-method-to-the-constructor\"><a href=\"#Moving-parameter-from-method-to-the-constructor\" class=\"headerlink\" title=\"Moving parameter from method to the constructor\"></a>Moving parameter from method to the constructor</h2><p>It may happen that we want to move a parameter from the method to a constructor to simplify the logic of the project. In order to that, we can move local variable to a class variable (in IntelliJ IDEA: <code>Ctrl+Alt+V</code> shortcut or <code>⌘+Alt+V</code> on Mac) and then create constructor with this variable (<code>Alt+Insert</code> or <code>⌘+N</code> on Mac).</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>As we can see, there are a few principles, which we may apply during code refactoring to make our project better. Moreover, most of them are supported by IntelliJ IDEA, which is great IDE. If you’re programming in another language than Java and want to have refactoring tools, you should check JetBrains products. Nevertheless, there’s no golden rule of refactoring. Sometimes it’s better to leave the code as it is. Especially if code-base is huge, the project is in production and there are no unit tests. If you want to know more about principles from this article, read <em>Test Driven Development</em> book by Kent Beck. Probably there are more principles than these described in this article. We should perform refactoring carefully and we need to remember about tests. Everything depends on the concrete project and our situation.</p>\n","more":"<h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><p>I’ve recently read a book about <em>Test Driven Development</em> by Kent Beck. It’s really good, presents the importance of the TDD and shows how to make a life of the software developer easier. In the TDD we follow <em>red-green-refactor</em> process in which we create a failing unit test, then we fix it and refactor it to make code-base better. There’s no golden rule when to refactor or how to refactor code and each project is different, but there are a few principles we may follow when we want to improve our projects through refactoring.</p>\n<h2 id=\"Finding-similarities-and-duplications\"><a href=\"#Finding-similarities-and-duplications\" class=\"headerlink\" title=\"Finding similarities and duplications\"></a>Finding similarities and duplications</h2><p>One of the common <em>code smells</em> is duplication. We should search for the following patterns:</p>\n<ul>\n<li>Two similar loops » try to merge them into one loop</li>\n<li>Two similar instructions inside conditional statements » try to unify operations and get rid of the “if” statement</li>\n<li>Two similar methods » try to unify them and remove one of them</li>\n<li>Two similar classes » try to unify them and remove one of them</li>\n<li>and so on…</li>\n</ul>\n<p>Perform these operations carefully. If something goes wrong, go one step backward. Sometimes it may be impossible to remove all duplications.</p>\n<h2 id=\"Isolating-changes\"><a href=\"#Isolating-changes\" class=\"headerlink\" title=\"Isolating changes\"></a>Isolating changes</h2><p>Before we start performing changes, it’s good to isolate a piece of code. We can move it e.g. to separate method, perform changes and then inline our method. That could help us avoid breaking the whole system.</p>\n<h2 id=\"Data-migration\"><a href=\"#Data-migration\" class=\"headerlink\" title=\"Data migration\"></a>Data migration</h2><p>If we want to change the meaning of the data, we can temporarily duplicate them, perform changes, update interfaces and then remove original code.</p>\n<h2 id=\"Method-extraction\"><a href=\"#Method-extraction\" class=\"headerlink\" title=\"Method extraction\"></a>Method extraction</h2><p>If a method in our class is too big (according to <em>Clean Code</em>, “too big” is longer than 20 lines), we should find code doing specialized mini-task and extract part of it to a separate method. In IntelliJ IDEA we can use <code>Ctrl+Alt+M</code> shortcut or <code>⌘+Alt+M</code> on Mac for that.</p>\n<h2 id=\"Method-inlining\"><a href=\"#Method-inlining\" class=\"headerlink\" title=\"Method inlining\"></a>Method inlining</h2><p>Sometimes, we’re extracting too many pieces of code to separate methods, what may decrease code readability. If the code inside the method is really simple, so it could be written in a single line or optionally in two lines, we may think about inlining this method. To do so, we should remove method and place code directly in the place where it’s called. To perform inlining in IntelliJ, we can use <code>Ctrl+Alt+N</code> shortcut or <code>⌘+Alt+N</code> on Mac.</p>\n<h2 id=\"Interface-extraction\"><a href=\"#Interface-extraction\" class=\"headerlink\" title=\"Interface extraction\"></a>Interface extraction</h2><p>When we want to create additional implementations of the operations, which already exists in our code-base, we may extract these operations into the interface. IntelliJ IDEA also has support for that. I’m not sure if there’s a shortcut, but you can use <code>Ctrl+Shit+A</code> shortcut or <code>⌘+Shift+A</code> on Mac to open window with operation search and then type <em>“extract interface”</em>. It should work.</p>\n<h2 id=\"Moving-method\"><a href=\"#Moving-method\" class=\"headerlink\" title=\"Moving method\"></a>Moving method</h2><p>It may happen, that our class or interface is becoming too big or it has methods, which are not directly related to this class. In such case, we may simply move one method or a few methods to another, more appropriate class or create a separate class or interface for them.</p>\n<h2 id=\"Object-method\"><a href=\"#Object-method\" class=\"headerlink\" title=\"Object-method\"></a>Object-method</h2><p>We may encounter a situation when a specific method has too many parameters. In such case, we may consider creating Object-method. It’s some kind of data class, which contains attributes the same as method parameters. It will help us to pass data in our system in a more readable way. We can also connect this solution with a Builder software design pattern.</p>\n<h2 id=\"Adding-parameter\"><a href=\"#Adding-parameter\" class=\"headerlink\" title=\"Adding parameter\"></a>Adding parameter</h2><p>During the time, the business logic of our system is getting bigger and one of our methods need to be extended. In such case, we can add another parameter to it. We may also consider creating another, similar method with just one more parameter. When we’re providing API or framework for other developers, we have to remember about proper “deprecated” annotations.</p>\n<h2 id=\"Moving-parameter-from-method-to-the-constructor\"><a href=\"#Moving-parameter-from-method-to-the-constructor\" class=\"headerlink\" title=\"Moving parameter from method to the constructor\"></a>Moving parameter from method to the constructor</h2><p>It may happen that we want to move a parameter from the method to a constructor to simplify the logic of the project. In order to that, we can move local variable to a class variable (in IntelliJ IDEA: <code>Ctrl+Alt+V</code> shortcut or <code>⌘+Alt+V</code> on Mac) and then create constructor with this variable (<code>Alt+Insert</code> or <code>⌘+N</code> on Mac).</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>As we can see, there are a few principles, which we may apply during code refactoring to make our project better. Moreover, most of them are supported by IntelliJ IDEA, which is great IDE. If you’re programming in another language than Java and want to have refactoring tools, you should check JetBrains products. Nevertheless, there’s no golden rule of refactoring. Sometimes it’s better to leave the code as it is. Especially if code-base is huge, the project is in production and there are no unit tests. If you want to know more about principles from this article, read <em>Test Driven Development</em> book by Kent Beck. Probably there are more principles than these described in this article. We should perform refactoring carefully and we need to remember about tests. Everything depends on the concrete project and our situation.</p>\n","categories":[],"tags":[{"name":"software-engineering","path":"api/tags/software-engineering.json"},{"name":"tdd","path":"api/tags/tdd.json"},{"name":"refactoring","path":"api/tags/refactoring.json"}]}