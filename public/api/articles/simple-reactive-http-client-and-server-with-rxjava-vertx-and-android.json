{"title":"Simple reactive HTTP client and server with RxJava, Vert.x and Android","slug":"simple-reactive-http-client-and-server-with-rxjava-vertx-and-android","date":"2017-11-09T21:30:00.000Z","updated":"2019-07-03T22:51:02.813Z","comments":true,"path":"api/articles/simple-reactive-http-client-and-server-with-rxjava-vertx-and-android.json","excerpt":null,"covers":["/images/posts/2017/simple-reactive-http-client-and-server-with-rxjava-vertx-and-android/virtual_sensors.png"],"content":"<p>During <a href=\"https://www.facebook.com/Hack.your.Career/\" target=\"_blank\" rel=\"noopener\">Hack Your Career</a> event at the Silesian University of Technology, I’ve prepared a presentation titled <a href=\"https://speakerdeck.com/pwittchen/reactive-programming-efficient-server-applications\" target=\"_blank\" rel=\"noopener\">Reactive Programming - Efficient Server Applications</a> with a colleague from work. Arek told about theory of Reactive Programming, shown basic concepts, data types and a few examples in the code. During my part of the presentation, I’ve wrote a very simple server and client in Java (9 on the server, 7 on the client) with <a href=\"http://vertx.io/\" target=\"_blank\" rel=\"noopener\">Vert.x</a> (<a href=\"http://vertx.io/docs/vertx-core/java/\" target=\"_blank\" rel=\"noopener\">Core</a> and <a href=\"http://vertx.io/docs/vertx-rx/java2/\" target=\"_blank\" rel=\"noopener\">Rx</a>), <a href=\"https://github.com/ReactiveX/RxJava\" target=\"_blank\" rel=\"noopener\">RxJava 2</a>, <a href=\"https://github.com/square/okhttp\" target=\"_blank\" rel=\"noopener\">OkHttp 3</a>, <a href=\"https://www.android.com/\" target=\"_blank\" rel=\"noopener\">Android</a> and <a href=\"https://github.com/ReactiveX/RxAndroid/\" target=\"_blank\" rel=\"noopener\">RxAndroid</a>. Presentation was targeted mainly to the university students with no experience with reactive programming, but it was an open event and anyone could attend it. Below, we can see a very simple code snippet showing how to create a reactive HTTP server with Vert.x. We can create a stream of requests, make <code>Flowable</code> out of it, apply any kind of RxJava 2 operator including backpressure handling and subscribe the stream. Moreover, we can also reactively start the server with <code>rxListen(int port)</code> method. This is just a basic example, where will be sending request to the only one endpoint. In the case, when we want to handle more endpoints, we can use <a href=\"http://vertx.io/docs/vertx-web/java/\" target=\"_blank\" rel=\"noopener\">vertx-web</a> library and design REST API.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> HttpServer server = Vertx</span><br><span class=\"line\">    .vertx()</span><br><span class=\"line\">    .createHttpServer();</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">    .requestStream()</span><br><span class=\"line\">    .toFlowable()</span><br><span class=\"line\">    .onBackpressureDrop()</span><br><span class=\"line\">    .subscribe(request -&gt; &#123;</span><br><span class=\"line\">      logger.info(<span class=\"string\">\"&#123;&#125; &#123;&#125;\"</span>, request.rawMethod(), request.absoluteURI());</span><br><span class=\"line\">      request.response().end(<span class=\"string\">\"request received\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">    .rxListen(<span class=\"number\">8080</span>)</span><br><span class=\"line\">    .subscribe(httpServer -&gt; logger.info(<span class=\"string\">\"server is running at port 8080...\"</span>));</span><br></pre></td></tr></table></figure>\n\n<p>We can build this server with Gradle as follows:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./gradlew shadowJar</span><br></pre></td></tr></table></figure>\n\n<p>and then, we can run it:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -jar build/libs/server-fat.jar</span><br></pre></td></tr></table></figure>\n\n<p>Our client will be an Android application, which will read data from the accelerometer sensor, send it to the server and display it in the <code>TextView</code> on a mobile device. We will use <a href=\"https://github.com/pwittchen/ReactiveSensors\" target=\"_blank\" rel=\"noopener\">ReactiveSensors</a> library (which was recently migrated to RxJava 2) for getting sensor readings as a <code>Flowable</code> data stream. Next, we will apply backpressure <code>DROP</code> strategy, filter only events of changing sensors (we neglect changing of the accuracy), read only one event per one second with <code>throttleLast(int, TimeUnit)</code> operator and map event to a String with device coordinates. Next, we are ready to send data with <code>Completable performRequest(String)</code>, which we created earlier. Sensors readings are acquired in the <code>computation()</code> scheduler, send to the server with <code>io()</code> scheduler and passed to the UI thread on Android with <code>AndroidSchedulers.mainThread()</code>. Distributing operations to the different schedulers is made with <code>subscribeOn(Scheduler)</code> and <code>observeOn(Scheduler)</code>.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reactiveSensors</span><br><span class=\"line\">    .observeSensor(Sensor.TYPE_ACCELEROMETER)</span><br><span class=\"line\">    .onBackpressureDrop()</span><br><span class=\"line\">    .filter(ReactiveSensorFilter.filterSensorChanged())</span><br><span class=\"line\">    .throttleLast(<span class=\"number\">1</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">    .map(<span class=\"keyword\">this</span>::getSensorReading)</span><br><span class=\"line\">    .doOnNext(event -&gt; performRequest(event)</span><br><span class=\"line\">        .subscribeOn(Schedulers.io())</span><br><span class=\"line\">        .subscribe())</span><br><span class=\"line\">    .subscribeOn(Schedulers.computation())</span><br><span class=\"line\">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class=\"line\">    .subscribe(event -&gt; tvReadings.setText(event));</span><br></pre></td></tr></table></figure>\n\n<p>It’s worth noticing that <code>Completable performRequest(String)</code> is using OkHttp 3 under the hood as a HTTP client, because it’s very simple example with one endpoint. In the case, we want to handle more endpoints on the client-side, it’s better to use <a href=\"https://github.com/square/retrofit\" target=\"_blank\" rel=\"noopener\">Retrofit</a> library. It’s also interesting that in our case, we can simulate behavior of the accelerometer and other sensors with the latest Android device emulator available in the Android SDK. It works surprisingly smooth. </p>\n<p><img src=\"/images/posts/2017/simple-reactive-http-client-and-server-with-rxjava-vertx-and-android/virtual_sensors.png\" alt=\"\"></p>\n<p><strong>Complete working example can be found at</strong>: <a href=\"https://github.com/pwittchen/reactive-client-server\" target=\"_blank\" rel=\"noopener\">https://github.com/pwittchen/reactive-client-server</a>. Later, I’ve also shown, how to use RxJava to distribute computational operations to a different threads of the CPU cores, but I’ll probably publish a separate article about that on this blog. It was the same example I shown during my JDD presentation this year. </p>\n<p>Slides from my part of the presentation are available below.</p>\n\n\n<script async class=\"speakerdeck-embed\" data-id=\"8acf7df50ffc461c8b0e3a6f03199767\" data-ratio=\"1.77777777777778\" src=\"//speakerdeck.com/assets/embed.js\"></script>\n\n\n\n<p><a href=\"https://speakerdeck.com/pwittchen/reactive-programming-efficient-server-applications\" target=\"_blank\" rel=\"noopener\">View slides on SpeakerDeck</a></p>\n","more":"<p>During <a href=\"https://www.facebook.com/Hack.your.Career/\" target=\"_blank\" rel=\"noopener\">Hack Your Career</a> event at the Silesian University of Technology, I’ve prepared a presentation titled <a href=\"https://speakerdeck.com/pwittchen/reactive-programming-efficient-server-applications\" target=\"_blank\" rel=\"noopener\">Reactive Programming - Efficient Server Applications</a> with a colleague from work. Arek told about theory of Reactive Programming, shown basic concepts, data types and a few examples in the code. During my part of the presentation, I’ve wrote a very simple server and client in Java (9 on the server, 7 on the client) with <a href=\"http://vertx.io/\" target=\"_blank\" rel=\"noopener\">Vert.x</a> (<a href=\"http://vertx.io/docs/vertx-core/java/\" target=\"_blank\" rel=\"noopener\">Core</a> and <a href=\"http://vertx.io/docs/vertx-rx/java2/\" target=\"_blank\" rel=\"noopener\">Rx</a>), <a href=\"https://github.com/ReactiveX/RxJava\" target=\"_blank\" rel=\"noopener\">RxJava 2</a>, <a href=\"https://github.com/square/okhttp\" target=\"_blank\" rel=\"noopener\">OkHttp 3</a>, <a href=\"https://www.android.com/\" target=\"_blank\" rel=\"noopener\">Android</a> and <a href=\"https://github.com/ReactiveX/RxAndroid/\" target=\"_blank\" rel=\"noopener\">RxAndroid</a>. Presentation was targeted mainly to the university students with no experience with reactive programming, but it was an open event and anyone could attend it. Below, we can see a very simple code snippet showing how to create a reactive HTTP server with Vert.x. We can create a stream of requests, make <code>Flowable</code> out of it, apply any kind of RxJava 2 operator including backpressure handling and subscribe the stream. Moreover, we can also reactively start the server with <code>rxListen(int port)</code> method. This is just a basic example, where will be sending request to the only one endpoint. In the case, when we want to handle more endpoints, we can use <a href=\"http://vertx.io/docs/vertx-web/java/\" target=\"_blank\" rel=\"noopener\">vertx-web</a> library and design REST API.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> HttpServer server = Vertx</span><br><span class=\"line\">    .vertx()</span><br><span class=\"line\">    .createHttpServer();</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">    .requestStream()</span><br><span class=\"line\">    .toFlowable()</span><br><span class=\"line\">    .onBackpressureDrop()</span><br><span class=\"line\">    .subscribe(request -&gt; &#123;</span><br><span class=\"line\">      logger.info(<span class=\"string\">\"&#123;&#125; &#123;&#125;\"</span>, request.rawMethod(), request.absoluteURI());</span><br><span class=\"line\">      request.response().end(<span class=\"string\">\"request received\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">    .rxListen(<span class=\"number\">8080</span>)</span><br><span class=\"line\">    .subscribe(httpServer -&gt; logger.info(<span class=\"string\">\"server is running at port 8080...\"</span>));</span><br></pre></td></tr></table></figure>\n\n<p>We can build this server with Gradle as follows:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./gradlew shadowJar</span><br></pre></td></tr></table></figure>\n\n<p>and then, we can run it:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -jar build/libs/server-fat.jar</span><br></pre></td></tr></table></figure>\n\n<p>Our client will be an Android application, which will read data from the accelerometer sensor, send it to the server and display it in the <code>TextView</code> on a mobile device. We will use <a href=\"https://github.com/pwittchen/ReactiveSensors\" target=\"_blank\" rel=\"noopener\">ReactiveSensors</a> library (which was recently migrated to RxJava 2) for getting sensor readings as a <code>Flowable</code> data stream. Next, we will apply backpressure <code>DROP</code> strategy, filter only events of changing sensors (we neglect changing of the accuracy), read only one event per one second with <code>throttleLast(int, TimeUnit)</code> operator and map event to a String with device coordinates. Next, we are ready to send data with <code>Completable performRequest(String)</code>, which we created earlier. Sensors readings are acquired in the <code>computation()</code> scheduler, send to the server with <code>io()</code> scheduler and passed to the UI thread on Android with <code>AndroidSchedulers.mainThread()</code>. Distributing operations to the different schedulers is made with <code>subscribeOn(Scheduler)</code> and <code>observeOn(Scheduler)</code>.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reactiveSensors</span><br><span class=\"line\">    .observeSensor(Sensor.TYPE_ACCELEROMETER)</span><br><span class=\"line\">    .onBackpressureDrop()</span><br><span class=\"line\">    .filter(ReactiveSensorFilter.filterSensorChanged())</span><br><span class=\"line\">    .throttleLast(<span class=\"number\">1</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">    .map(<span class=\"keyword\">this</span>::getSensorReading)</span><br><span class=\"line\">    .doOnNext(event -&gt; performRequest(event)</span><br><span class=\"line\">        .subscribeOn(Schedulers.io())</span><br><span class=\"line\">        .subscribe())</span><br><span class=\"line\">    .subscribeOn(Schedulers.computation())</span><br><span class=\"line\">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class=\"line\">    .subscribe(event -&gt; tvReadings.setText(event));</span><br></pre></td></tr></table></figure>\n\n<p>It’s worth noticing that <code>Completable performRequest(String)</code> is using OkHttp 3 under the hood as a HTTP client, because it’s very simple example with one endpoint. In the case, we want to handle more endpoints on the client-side, it’s better to use <a href=\"https://github.com/square/retrofit\" target=\"_blank\" rel=\"noopener\">Retrofit</a> library. It’s also interesting that in our case, we can simulate behavior of the accelerometer and other sensors with the latest Android device emulator available in the Android SDK. It works surprisingly smooth. </p>\n<p><img src=\"/images/posts/2017/simple-reactive-http-client-and-server-with-rxjava-vertx-and-android/virtual_sensors.png\" alt=\"\"></p>\n<p><strong>Complete working example can be found at</strong>: <a href=\"https://github.com/pwittchen/reactive-client-server\" target=\"_blank\" rel=\"noopener\">https://github.com/pwittchen/reactive-client-server</a>. Later, I’ve also shown, how to use RxJava to distribute computational operations to a different threads of the CPU cores, but I’ll probably publish a separate article about that on this blog. It was the same example I shown during my JDD presentation this year. </p>\n<p>Slides from my part of the presentation are available below.</p>\n\n\n<script async class=\"speakerdeck-embed\" data-id=\"8acf7df50ffc461c8b0e3a6f03199767\" data-ratio=\"1.77777777777778\" src=\"//speakerdeck.com/assets/embed.js\"></script>\n\n\n\n<p><a href=\"https://speakerdeck.com/pwittchen/reactive-programming-efficient-server-applications\" target=\"_blank\" rel=\"noopener\">View slides on SpeakerDeck</a></p>\n","categories":[],"tags":[{"name":"java","path":"api/tags/java.json"},{"name":"android","path":"api/tags/android.json"},{"name":"rxjava","path":"api/tags/rxjava.json"},{"name":"vertx","path":"api/tags/vertx.json"},{"name":"http","path":"api/tags/http.json"},{"name":"client-server","path":"api/tags/client-server.json"}]}