{"title":"Emitting different observables conditionally","slug":"emitting-different-rxjava-observables-depending-on-the-condition-with-flatmap","date":"2017-05-14T19:44:00.000Z","updated":"2019-07-03T22:51:02.810Z","comments":true,"path":"api/articles/emitting-different-rxjava-observables-depending-on-the-condition-with-flatmap.json","excerpt":null,"covers":null,"content":"<p>Sometimes, we may need to emit different RxJava Observables depending on the specific condition dynamically. Moreover, it’s good to do it right without breaking a chain (stream of Observables). We want to combine different Observables together and do not want to nest one subscription inside another subscription because this will lead us to “subscription hell” similar to “callback hell”. Luckily RxJava has mechanisms to deal with such problems. In this article, I’m basing my examples on RxJava 2.1.0. Let’s say we have two Observables:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;String&gt; <span class=\"title\">trueObservable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Observable.fromCallable(() -&gt; <span class=\"string\">\"trueObservable\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;String&gt; <span class=\"title\">falseObservable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Observable.fromCallable(() -&gt; <span class=\"string\">\"falseObservable\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>and we have another Observable wrapping <code>Boolean</code> value:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;Boolean&gt; <span class=\"title\">createCondition</span><span class=\"params\">(<span class=\"keyword\">boolean</span> returnedValue)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Observable.fromCallable(() -&gt; returnedValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>This Observable can emit <code>true</code> or <code>false</code> depending on the provided parameter. What we want to do is to:</p>\n<ul>\n<li>emit <code>trueObservable()</code> when <code>createCondition(boolean)</code> returns <code>true</code></li>\n<li>emit <code>falseObservable()</code> when <code>createCondition(boolean)</code> returns <code>false</code></li>\n<li>emit <code>falseObservable()</code> when <code>createCondition(boolean)</code> emits empty Observable (default behaviour)</li>\n</ul>\n<p>We can do it in the following way:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;String&gt; <span class=\"title\">emitTrueObservableDynamically</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> createCondition(<span class=\"keyword\">true</span>)</span><br><span class=\"line\">      .defaultIfEmpty(<span class=\"keyword\">false</span>)</span><br><span class=\"line\">      .flatMap(condition -&gt; condition ? trueObservable() : falseObservable());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>In such case, this method will emit <code>trueObservable()</code>. When we change parameter of the <code>createCondition(boolean)</code> method to false, Observable will emit <code>falseObservable()</code>. When we replace <code>createCondition(boolean)</code> method with <code>Observable.empty()</code>, method will return <code>falseObservable()</code> by default. As we can see, it’s easily solved with <a href=\"http://reactivex.io/documentation/operators/flatmap.html\" target=\"_blank\" rel=\"noopener\">flatMap</a> and <a href=\"http://reactivex.io/documentation/operators/defaultifempty.html\" target=\"_blank\" rel=\"noopener\">defaultIfEmpty</a> operators. This is quite useful technique, which we can apply to reactive applications to control our flow without breaking the chain. Please note, it’s just an example you can create more complicated constructions and handle more complicated types than just boolean and more than two use cases.</p>\n<hr>\n<p>Reference thread for this article on StackOverflow: <a href=\"http://stackoverflow.com/questions/34195218/rxjava-exequte-observable-only-if-first-was-empty\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/34195218/rxjava-exequte-observable-only-if-first-was-empty</a>.</p>\n","more":"<p>Sometimes, we may need to emit different RxJava Observables depending on the specific condition dynamically. Moreover, it’s good to do it right without breaking a chain (stream of Observables). We want to combine different Observables together and do not want to nest one subscription inside another subscription because this will lead us to “subscription hell” similar to “callback hell”. Luckily RxJava has mechanisms to deal with such problems. In this article, I’m basing my examples on RxJava 2.1.0. Let’s say we have two Observables:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;String&gt; <span class=\"title\">trueObservable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Observable.fromCallable(() -&gt; <span class=\"string\">\"trueObservable\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;String&gt; <span class=\"title\">falseObservable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Observable.fromCallable(() -&gt; <span class=\"string\">\"falseObservable\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>and we have another Observable wrapping <code>Boolean</code> value:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;Boolean&gt; <span class=\"title\">createCondition</span><span class=\"params\">(<span class=\"keyword\">boolean</span> returnedValue)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Observable.fromCallable(() -&gt; returnedValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>This Observable can emit <code>true</code> or <code>false</code> depending on the provided parameter. What we want to do is to:</p>\n<ul>\n<li>emit <code>trueObservable()</code> when <code>createCondition(boolean)</code> returns <code>true</code></li>\n<li>emit <code>falseObservable()</code> when <code>createCondition(boolean)</code> returns <code>false</code></li>\n<li>emit <code>falseObservable()</code> when <code>createCondition(boolean)</code> emits empty Observable (default behaviour)</li>\n</ul>\n<p>We can do it in the following way:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;String&gt; <span class=\"title\">emitTrueObservableDynamically</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> createCondition(<span class=\"keyword\">true</span>)</span><br><span class=\"line\">      .defaultIfEmpty(<span class=\"keyword\">false</span>)</span><br><span class=\"line\">      .flatMap(condition -&gt; condition ? trueObservable() : falseObservable());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>In such case, this method will emit <code>trueObservable()</code>. When we change parameter of the <code>createCondition(boolean)</code> method to false, Observable will emit <code>falseObservable()</code>. When we replace <code>createCondition(boolean)</code> method with <code>Observable.empty()</code>, method will return <code>falseObservable()</code> by default. As we can see, it’s easily solved with <a href=\"http://reactivex.io/documentation/operators/flatmap.html\" target=\"_blank\" rel=\"noopener\">flatMap</a> and <a href=\"http://reactivex.io/documentation/operators/defaultifempty.html\" target=\"_blank\" rel=\"noopener\">defaultIfEmpty</a> operators. This is quite useful technique, which we can apply to reactive applications to control our flow without breaking the chain. Please note, it’s just an example you can create more complicated constructions and handle more complicated types than just boolean and more than two use cases.</p>\n<hr>\n<p>Reference thread for this article on StackOverflow: <a href=\"http://stackoverflow.com/questions/34195218/rxjava-exequte-observable-only-if-first-was-empty\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/34195218/rxjava-exequte-observable-only-if-first-was-empty</a>.</p>\n","categories":[],"tags":[{"name":"java","path":"api/tags/java.json"},{"name":"rxjava","path":"api/tags/rxjava.json"}]}