{"title":"Get past the syntax - the real scare is in the semantics","slug":"get-past-the-syntax","date":"2015-07-06T13:37:00.000Z","updated":"2019-07-03T22:51:02.810Z","comments":true,"path":"api/articles/get-past-the-syntax.json","excerpt":null,"covers":null,"content":"<p>Dr. <a href=\"http://agiledeveloper.com/\" target=\"_blank\" rel=\"noopener\">Venkat Subramaniam</a> presented an interesting point of view during his talk at Devoxx conference. Programmers, who start learning a new language, often complain about syntax. They focus on using available keywords and constructions instead of trying to understand their meaning and purpose. Programmers also have their own habits. That’s why Java has similar syntax to C and C++. Creators of Java designed new language with syntax, which was familiar to them, with significant improvements. Perception of the world is based on experience and things we get used to. The same rule applies to programming languages. Most software developers are familiar with imperative programming paradigm. They often focus on describing computation in terms of statements and changing program state. This approach leads us to necessity of creating a lot of temporary variables and boilerplate code. Let’s have a look at the following code snippet: </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> limit = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> i = start;</span><br><span class=\"line\"><span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span>[] evenNumbers = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[limit];</span><br><span class=\"line\"><span class=\"keyword\">double</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (j &lt; evenNumbers.length) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    evenNumbers[j] = i;</span><br><span class=\"line\">    j++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  i++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; evenNumbers.length; k++) &#123;</span><br><span class=\"line\">  sum += Math.sqrt(evenNumbers[k]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(sum);</span><br><span class=\"line\">view raw</span><br></pre></td></tr></table></figure>\n\n<p>This code prints sum of the square roots of the first ten even numbers starting from zero. It’s not so complicated task, but there is a lot of code, temporary variables, two loops, we have to be careful with operators to avoid <code>ArrayIndexOutOfBoundsException</code> and so on. Moreover, code is quite hard to analyze and we can make a mistake in many places. Let’s see what happens when we use functional programming approach, Java 8 with stream API and lambdas. We can do the same task in the following way: </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> limit = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> sum = Stream</span><br><span class=\"line\">               .iterate(start, e -&gt; e + <span class=\"number\">1</span>)</span><br><span class=\"line\">               .filter(e -&gt; e % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">               .map(Math::sqrt)</span><br><span class=\"line\">               .limit(limit)</span><br><span class=\"line\">               .reduce(<span class=\"number\">0.0</span>, Double::sum);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(sum);</span><br></pre></td></tr></table></figure>\n\n<p>As we can see, the code is simpler, cleaner and easier to analyze. The only difference is the fact that we changed approach from imperative to the functional one and applied different semantics. In this case, instead of focusing on how to do the task, we focused on the result we want to obtain. Instead of learning only syntax, we should spend more time on learning semantics to understand its purpose. This will allow us to create better and robust solutions in less time. </p>\n<p><em>This article was also published as a part of summary of Devoxx 2015 Conference in Kraków, Poland on technical blog of Future Processing:</em> <a href=\"http://www.future-processing.pl/blog/devoxx-conference-summary/\" target=\"_blank\" rel=\"noopener\">http://www.future-processing.pl/blog/devoxx-conference-summary/</a></p>\n","more":"<p>Dr. <a href=\"http://agiledeveloper.com/\" target=\"_blank\" rel=\"noopener\">Venkat Subramaniam</a> presented an interesting point of view during his talk at Devoxx conference. Programmers, who start learning a new language, often complain about syntax. They focus on using available keywords and constructions instead of trying to understand their meaning and purpose. Programmers also have their own habits. That’s why Java has similar syntax to C and C++. Creators of Java designed new language with syntax, which was familiar to them, with significant improvements. Perception of the world is based on experience and things we get used to. The same rule applies to programming languages. Most software developers are familiar with imperative programming paradigm. They often focus on describing computation in terms of statements and changing program state. This approach leads us to necessity of creating a lot of temporary variables and boilerplate code. Let’s have a look at the following code snippet: </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> limit = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> i = start;</span><br><span class=\"line\"><span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span>[] evenNumbers = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[limit];</span><br><span class=\"line\"><span class=\"keyword\">double</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (j &lt; evenNumbers.length) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    evenNumbers[j] = i;</span><br><span class=\"line\">    j++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  i++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; evenNumbers.length; k++) &#123;</span><br><span class=\"line\">  sum += Math.sqrt(evenNumbers[k]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(sum);</span><br><span class=\"line\">view raw</span><br></pre></td></tr></table></figure>\n\n<p>This code prints sum of the square roots of the first ten even numbers starting from zero. It’s not so complicated task, but there is a lot of code, temporary variables, two loops, we have to be careful with operators to avoid <code>ArrayIndexOutOfBoundsException</code> and so on. Moreover, code is quite hard to analyze and we can make a mistake in many places. Let’s see what happens when we use functional programming approach, Java 8 with stream API and lambdas. We can do the same task in the following way: </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> limit = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> sum = Stream</span><br><span class=\"line\">               .iterate(start, e -&gt; e + <span class=\"number\">1</span>)</span><br><span class=\"line\">               .filter(e -&gt; e % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">               .map(Math::sqrt)</span><br><span class=\"line\">               .limit(limit)</span><br><span class=\"line\">               .reduce(<span class=\"number\">0.0</span>, Double::sum);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(sum);</span><br></pre></td></tr></table></figure>\n\n<p>As we can see, the code is simpler, cleaner and easier to analyze. The only difference is the fact that we changed approach from imperative to the functional one and applied different semantics. In this case, instead of focusing on how to do the task, we focused on the result we want to obtain. Instead of learning only syntax, we should spend more time on learning semantics to understand its purpose. This will allow us to create better and robust solutions in less time. </p>\n<p><em>This article was also published as a part of summary of Devoxx 2015 Conference in Kraków, Poland on technical blog of Future Processing:</em> <a href=\"http://www.future-processing.pl/blog/devoxx-conference-summary/\" target=\"_blank\" rel=\"noopener\">http://www.future-processing.pl/blog/devoxx-conference-summary/</a></p>\n","categories":[],"tags":[{"name":"java","path":"api/tags/java.json"},{"name":"conferences","path":"api/tags/conferences.json"},{"name":"devoxx","path":"api/tags/devoxx.json"}]}