<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Test coverage report for Android application | Piotr Wittchen</title><meta name=keywords content="android,testing"><meta name=description content="Update: see newer article about Unit test coverage report with Travis CI for Robolectric on Android. For a long time, I wasn&rsquo;t able to find the right way to generate test coverage reports for Android instrumentation unit tests created with AndroidJUnit4 runner. In the past I&rsquo;ve found many solutions, but none of them was working or they were compatible only with Robolectric, which I currently don&rsquo;t use. Other developers also stopped using it for the new projects. E.g. Sqlbrite from Square is using AndroidJUnit4 runner as my projects do. Recently, I&rsquo;ve found an interesting discussion on Reddit, where we can find information about enabling test coverage very easily without additional plugins, scripts and many lines of configuration. Moreover, Android SDK currently has built-in support for Emma Test Coverage, what we can read in official documentation. Basically, the only thing we need to do, is to apply jacoco-android plugin in build.gradle file:"><meta name=author content="Piotr Wittchen"><link rel=canonical href=https://wittchen.io/notes/test-coverage-in-android-applications/><link crossorigin=anonymous href=/assets/css/stylesheet.e70ef7043b0f0268f4c98753143525282e28cccf526c6be509a7fbd3e2028037.css integrity="sha256-5w73BDsPAmj0yYdTFDUlKC4ozM9SbGvlCaf70+ICgDc=" rel="preload stylesheet" as=style><link rel=icon href=https://wittchen.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wittchen.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wittchen.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wittchen.io/apple-touch-icon.png><link rel=mask-icon href=https://wittchen.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://wittchen.io/notes/test-coverage-in-android-applications/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wittchen.io/notes/test-coverage-in-android-applications/"><meta property="og:site_name" content="Piotr Wittchen"><meta property="og:title" content="Test coverage report for Android application"><meta property="og:description" content="Update: see newer article about Unit test coverage report with Travis CI for Robolectric on Android. For a long time, I wasn’t able to find the right way to generate test coverage reports for Android instrumentation unit tests created with AndroidJUnit4 runner. In the past I’ve found many solutions, but none of them was working or they were compatible only with Robolectric, which I currently don’t use. Other developers also stopped using it for the new projects. E.g. Sqlbrite from Square is using AndroidJUnit4 runner as my projects do. Recently, I’ve found an interesting discussion on Reddit, where we can find information about enabling test coverage very easily without additional plugins, scripts and many lines of configuration. Moreover, Android SDK currently has built-in support for Emma Test Coverage, what we can read in official documentation. Basically, the only thing we need to do, is to apply jacoco-android plugin in build.gradle file:"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:published_time" content="2015-06-03T18:22:00+00:00"><meta property="article:modified_time" content="2015-06-03T18:22:00+00:00"><meta property="article:tag" content="Android"><meta property="article:tag" content="Testing"><meta name=twitter:card content="summary"><meta name=twitter:title content="Test coverage report for Android application"><meta name=twitter:description content="Update: see newer article about Unit test coverage report with Travis CI for Robolectric on Android. For a long time, I wasn&rsquo;t able to find the right way to generate test coverage reports for Android instrumentation unit tests created with AndroidJUnit4 runner. In the past I&rsquo;ve found many solutions, but none of them was working or they were compatible only with Robolectric, which I currently don&rsquo;t use. Other developers also stopped using it for the new projects. E.g. Sqlbrite from Square is using AndroidJUnit4 runner as my projects do. Recently, I&rsquo;ve found an interesting discussion on Reddit, where we can find information about enabling test coverage very easily without additional plugins, scripts and many lines of configuration. Moreover, Android SDK currently has built-in support for Emma Test Coverage, what we can read in official documentation. Basically, the only thing we need to do, is to apply jacoco-android plugin in build.gradle file:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://wittchen.io/notes/"},{"@type":"ListItem","position":2,"name":"Test coverage report for Android application","item":"https://wittchen.io/notes/test-coverage-in-android-applications/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Test coverage report for Android application","name":"Test coverage report for Android application","description":"Update: see newer article about Unit test coverage report with Travis CI for Robolectric on Android. For a long time, I wasn\u0026rsquo;t able to find the right way to generate test coverage reports for Android instrumentation unit tests created with AndroidJUnit4 runner. In the past I\u0026rsquo;ve found many solutions, but none of them was working or they were compatible only with Robolectric, which I currently don\u0026rsquo;t use. Other developers also stopped using it for the new projects. E.g. Sqlbrite from Square is using AndroidJUnit4 runner as my projects do. Recently, I\u0026rsquo;ve found an interesting discussion on Reddit, where we can find information about enabling test coverage very easily without additional plugins, scripts and many lines of configuration. Moreover, Android SDK currently has built-in support for Emma Test Coverage, what we can read in official documentation. Basically, the only thing we need to do, is to apply jacoco-android plugin in build.gradle file:\n","keywords":["android","testing"],"articleBody":"Update: see newer article about Unit test coverage report with Travis CI for Robolectric on Android. For a long time, I wasn’t able to find the right way to generate test coverage reports for Android instrumentation unit tests created with AndroidJUnit4 runner. In the past I’ve found many solutions, but none of them was working or they were compatible only with Robolectric, which I currently don’t use. Other developers also stopped using it for the new projects. E.g. Sqlbrite from Square is using AndroidJUnit4 runner as my projects do. Recently, I’ve found an interesting discussion on Reddit, where we can find information about enabling test coverage very easily without additional plugins, scripts and many lines of configuration. Moreover, Android SDK currently has built-in support for Emma Test Coverage, what we can read in official documentation. Basically, the only thing we need to do, is to apply jacoco-android plugin in build.gradle file:\napply plugin: 'jacoco-android' and then set testCoverageEnabled parameter to true as follows:\nandroid { buildTypes { debug { testCoverageEnabled = true } } } In order to create test coverage report, we need Android device or emulator connected to the computer, because connectedCheck task needs to be executed before creating the report. Next, we can execute the following Gradle task from CLI:\n./gradlew createDebugCoverageReport Task will analyze code of our project in /src/main/java/ directory and unit tests placed in /src/androidTest/java/ directory. After executing this task, we can find test coverage report in the following directory of the module:\n/build/outputs/reports/coverage/debug/ When we open index.html file, we can see visual report from test coverage, which can be viewed in a web browser. Moreover, in the same directory, we can find report.xml file, which can used for test coverage analysis on continuous integration server. Besides mentioned files, Gradle will generate coverage.ec file in the following directory:\n/build/outputs/code-coverage/connected/ In some cases, we may need this file. E.g. if chosen Jenkins plugin or another tool will need it in order to generate test coverage report properly. Below, you can see exemplary test coverage report for Prefser, which is an open-source Android library.\nThis report was generated with JaCoCo code coverage library. After analyzing test coverage report, I’ve added a few new unit tests, slightly modified the project and managed to obtain 100% test coverage.\nIn order to publish our report on Jenkins CI, we can use test coverage plugins, but I am not sure about their stability. Another solution is HTML Publisher plugin. We can add post-build action and publish our test coverage report generated by default as HTML website inside Jenkins job. In my opinion, it’s quite convenient solution, because it is easy to set up and allows us to navigate to the code, browse uncovered lines, methods and branches. Finally, with this clean and fast solution we can easily monitor test coverage of our Android projects, find bottlenecks and increase overall quality of the applications and libraries.\nLink to the old blog post archive with comments of the users: https://web.archive.org/web/20171210224809/http://blog.wittchen.biz.pl/test-coverage-report-for-android-application\n","wordCount":"498","inLanguage":"en","datePublished":"2015-06-03T18:22:00Z","dateModified":"2015-06-03T18:22:00Z","author":{"@type":"Person","name":"Piotr Wittchen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wittchen.io/notes/test-coverage-in-android-applications/"},"publisher":{"@type":"Organization","name":"Piotr Wittchen","logo":{"@type":"ImageObject","url":"https://wittchen.io/favicon.ico"}}}</script><script defer data-website-id=dfid_D4sN47CVgrrCRR7KCciN3 data-domain=wittchen.io src=https://datafa.st/js/script.js></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wittchen.io/ accesskey=h title="Piotr Wittchen (Alt + H)">Piotr Wittchen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wittchen.io/notes/ title=notes><span>notes</span></a></li><li><a href=https://wittchen.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://wittchen.io/talks/ title=talks><span>talks</span></a></li><li><a href=https://wittchen.io/projects/ title=projects><span>projects</span></a></li><li><a href=https://wittchen.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://wittchen.io/contact/ title=contact><span>contact</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wittchen.io/>Home</a>&nbsp;»&nbsp;<a href=https://wittchen.io/notes/>Notes</a></div><h1 class="post-title entry-hint-parent">Test coverage report for Android application</h1><div class=post-meta><span title='2015-06-03 18:22:00 +0000 UTC'>June 3, 2015</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;498 words&nbsp;·&nbsp;Piotr Wittchen&nbsp;|&nbsp;<a href=https://github.com/pwittchen/wittchen.io/blob/master/content/notes/test-coverage-in-android-applications.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p><strong>Update:</strong> see newer article about <a href=/unit-test-coverage-report-with-travis-ci-for-robolectric-on-android/><strong>Unit test coverage report with Travis CI for Robolectric on Android</strong></a>. For a long time, I wasn&rsquo;t able to find the right way to generate test coverage reports for Android instrumentation unit tests created with AndroidJUnit4 runner. In the past I&rsquo;ve found many solutions, but none of them was working or they were compatible only with Robolectric, which I currently don&rsquo;t use. Other developers also stopped using it for the new projects. E.g. <a href=https://github.com/square/sqlbrite>Sqlbrite</a> from Square is using AndroidJUnit4 runner as my projects do. Recently, I&rsquo;ve found <a href=http://www.reddit.com/r/androiddev/comments/2v1n2u/code_coverage_in_android_studio/>an interesting discussion on Reddit</a>, where we can find information about enabling test coverage very easily without additional plugins, scripts and many lines of configuration. Moreover, Android SDK currently has built-in support for <a href=http://emma.sourceforge.net/>Emma Test Coverage</a>, what we can read in <a href=http://developer.android.com/reference/android/test/InstrumentationTestRunner.html>official documentation</a>. Basically, the only thing we need to do, is to apply <code>jacoco-android</code> plugin in <code>build.gradle</code> file:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gradle data-lang=gradle><span class=line><span class=cl><span class=n>apply</span> <span class=nl>plugin:</span> <span class=s1>&#39;jacoco-android&#39;</span>
</span></span></code></pre></div><p>and then set <code>testCoverageEnabled</code> parameter to <code>true</code> as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gradle data-lang=gradle><span class=line><span class=cl><span class=n>android</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>   <span class=n>buildTypes</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>debug</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>         <span class=n>testCoverageEnabled</span> <span class=o>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>   <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>In order to create test coverage report, we need Android device or emulator connected to the computer, because <code>connectedCheck</code> task needs to be executed before creating the report. Next, we can execute the following Gradle task from CLI:</p><pre tabindex=0><code>./gradlew createDebugCoverageReport
</code></pre><p>Task will analyze code of our project in <code>/src/main/java/</code> directory and unit tests placed in <code>/src/androidTest/java/</code> directory. After executing this task, we can find test coverage report in the following directory of the module:</p><pre tabindex=0><code>/build/outputs/reports/coverage/debug/
</code></pre><p>When we open <code>index.html</code> file, we can see visual report from test coverage, which can be viewed in a web browser. Moreover, in the same directory, we can find <code>report.xml</code> file, which can used for test coverage analysis on continuous integration server. Besides mentioned files, Gradle will generate <code>coverage.ec</code> file in the following directory:</p><pre tabindex=0><code>/build/outputs/code-coverage/connected/
</code></pre><p>In some cases, we may need this file. E.g. if chosen Jenkins plugin or another tool will need it in order to generate test coverage report properly. Below, you can see exemplary test coverage report for <a href=https://github.com/pwittchen/prefser>Prefser</a>, which is an open-source Android library.</p><p><img alt=prefser_test_coverage_report_03.06.2015 loading=lazy src=/posts/2015/test-coverage/prefser_test_coverage_report_03.06.2015.png></p><p>This report was generated with <a href=http://www.eclemma.org/jacoco/>JaCoCo</a> code coverage library. After analyzing test coverage report, I&rsquo;ve added a few new unit tests, slightly modified the project and managed to obtain <strong>100% test coverage</strong>.</p><p><img alt=prefser_test_coverage_04.06.2015 loading=lazy src=/posts/2015/test-coverage/prefser_test_coverage_04.06.2015.png></p><p>In order to publish our report on Jenkins CI, we can use test coverage plugins, but I am not sure about their stability. Another solution is <a href=https://wiki.jenkins-ci.org/display/JENKINS/HTML+Publisher+Plugin>HTML Publisher plugin</a>. We can add post-build action and publish our test coverage report generated by default as HTML website inside Jenkins job. In my opinion, it&rsquo;s quite convenient solution, because it is easy to set up and allows us to navigate to the code, browse uncovered lines, methods and branches. Finally, with this clean and fast solution we can easily monitor test coverage of our Android projects, find bottlenecks and increase overall quality of the applications and libraries.</p><p><strong>Link to the old blog post archive with comments of the users</strong>: <a href=https://web.archive.org/web/20171210224809/http://blog.wittchen.biz.pl/test-coverage-report-for-android-application>https://web.archive.org/web/20171210224809/http://blog.wittchen.biz.pl/test-coverage-report-for-android-application</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wittchen.io/tags/android/>Android</a></li><li><a href=https://wittchen.io/tags/testing/>Testing</a></li></ul><nav class=paginav><a class=prev href=https://wittchen.io/notes/releasing-prefser-v-105/><span class=title>« Prev</span><br><span>Releasing prefser v. 1.0.5</span>
</a><a class=next href=https://wittchen.io/notes/checking-consistency-of-git-branches/><span class=title>Next »</span><br><span>Checking consistency of git branches</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://wittchen.io/>Piotr Wittchen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a> (modified | inspired by <a href=https://ui.shadcn.com/ rel=noopener target=_blank>shadcn-ui</a>)</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){const e=document.querySelector(".header");if(!e)return;function t(){window.scrollY>10?e.classList.add("scrolled"):e.classList.remove("scrolled")}window.addEventListener("scroll",t,{passive:!0}),t()})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>