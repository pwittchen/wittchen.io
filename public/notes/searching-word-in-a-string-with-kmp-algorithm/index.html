<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Searching word in a string with KMP algorithm | Piotr Wittchen</title><meta name=keywords content="java"><meta name=description content="Sometimes it&rsquo;s good to revise some algorithms and try to implement them in order to get to know, how the built-in functions of high level programming languages actually works. One of the popular problems is string searching. We have many approaches to solve this problem. For example:

Naive string search algorithm
Rabin-Karp string search algorithm
Finite-state automaton based search
Knuth-Morris-Pratt algorithm
Boyer-Moore string search algorithm
Bitap algorithm

This time, I&rsquo;ve decided to focus on Knuth-Morris-Pratt (KMP) algorithm. It&rsquo;s quite easy to implement, when you understand it. In addition, its time complexity is quite good and can be defined as O(n). In this algorithm, we simply go through all letters in a given string and compare them with searched string. When position of searched string reaches length of searched string, we can assume, that our string was found. If two compared letters are different, we set position of searched string to zero and start new search from the next position after which we started searching process before. It&rsquo;s quite good described on Wikipedia with some pseudo-code. You can also take a look at my code in Java available below, which I&rsquo;ve written just for practice."><meta name=author content="Piotr Wittchen"><link rel=canonical href=https://wittchen.io/notes/searching-word-in-a-string-with-kmp-algorithm/><link crossorigin=anonymous href=/assets/css/stylesheet.ce07c2a628121ab9051d703ded1d918162d348e5c03783b702262170087c359e.css integrity="sha256-zgfCpigSGrkFHXA97R2RgWLTSOXAN4O3AiYhcAh8NZ4=" rel="preload stylesheet" as=style><link rel=icon href=https://wittchen.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wittchen.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wittchen.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wittchen.io/apple-touch-icon.png><link rel=mask-icon href=https://wittchen.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://wittchen.io/notes/searching-word-in-a-string-with-kmp-algorithm/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wittchen.io/notes/searching-word-in-a-string-with-kmp-algorithm/"><meta property="og:site_name" content="Piotr Wittchen"><meta property="og:title" content="Searching word in a string with KMP algorithm"><meta property="og:description" content="Sometimes it’s good to revise some algorithms and try to implement them in order to get to know, how the built-in functions of high level programming languages actually works. One of the popular problems is string searching. We have many approaches to solve this problem. For example:
Naive string search algorithm Rabin-Karp string search algorithm Finite-state automaton based search Knuth-Morris-Pratt algorithm Boyer-Moore string search algorithm Bitap algorithm This time, I’ve decided to focus on Knuth-Morris-Pratt (KMP) algorithm. It’s quite easy to implement, when you understand it. In addition, its time complexity is quite good and can be defined as O(n). In this algorithm, we simply go through all letters in a given string and compare them with searched string. When position of searched string reaches length of searched string, we can assume, that our string was found. If two compared letters are different, we set position of searched string to zero and start new search from the next position after which we started searching process before. It’s quite good described on Wikipedia with some pseudo-code. You can also take a look at my code in Java available below, which I’ve written just for practice."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:published_time" content="2015-07-22T13:03:00+00:00"><meta property="article:modified_time" content="2015-07-22T13:03:00+00:00"><meta property="article:tag" content="Java"><meta name=twitter:card content="summary"><meta name=twitter:title content="Searching word in a string with KMP algorithm"><meta name=twitter:description content="Sometimes it&rsquo;s good to revise some algorithms and try to implement them in order to get to know, how the built-in functions of high level programming languages actually works. One of the popular problems is string searching. We have many approaches to solve this problem. For example:

Naive string search algorithm
Rabin-Karp string search algorithm
Finite-state automaton based search
Knuth-Morris-Pratt algorithm
Boyer-Moore string search algorithm
Bitap algorithm

This time, I&rsquo;ve decided to focus on Knuth-Morris-Pratt (KMP) algorithm. It&rsquo;s quite easy to implement, when you understand it. In addition, its time complexity is quite good and can be defined as O(n). In this algorithm, we simply go through all letters in a given string and compare them with searched string. When position of searched string reaches length of searched string, we can assume, that our string was found. If two compared letters are different, we set position of searched string to zero and start new search from the next position after which we started searching process before. It&rsquo;s quite good described on Wikipedia with some pseudo-code. You can also take a look at my code in Java available below, which I&rsquo;ve written just for practice."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://wittchen.io/notes/"},{"@type":"ListItem","position":2,"name":"Searching word in a string with KMP algorithm","item":"https://wittchen.io/notes/searching-word-in-a-string-with-kmp-algorithm/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Searching word in a string with KMP algorithm","name":"Searching word in a string with KMP algorithm","description":"Sometimes it\u0026rsquo;s good to revise some algorithms and try to implement them in order to get to know, how the built-in functions of high level programming languages actually works. One of the popular problems is string searching. We have many approaches to solve this problem. For example:\nNaive string search algorithm Rabin-Karp string search algorithm Finite-state automaton based search Knuth-Morris-Pratt algorithm Boyer-Moore string search algorithm Bitap algorithm This time, I\u0026rsquo;ve decided to focus on Knuth-Morris-Pratt (KMP) algorithm. It\u0026rsquo;s quite easy to implement, when you understand it. In addition, its time complexity is quite good and can be defined as O(n). In this algorithm, we simply go through all letters in a given string and compare them with searched string. When position of searched string reaches length of searched string, we can assume, that our string was found. If two compared letters are different, we set position of searched string to zero and start new search from the next position after which we started searching process before. It\u0026rsquo;s quite good described on Wikipedia with some pseudo-code. You can also take a look at my code in Java available below, which I\u0026rsquo;ve written just for practice.\n","keywords":["java"],"articleBody":"Sometimes it’s good to revise some algorithms and try to implement them in order to get to know, how the built-in functions of high level programming languages actually works. One of the popular problems is string searching. We have many approaches to solve this problem. For example:\nNaive string search algorithm Rabin-Karp string search algorithm Finite-state automaton based search Knuth-Morris-Pratt algorithm Boyer-Moore string search algorithm Bitap algorithm This time, I’ve decided to focus on Knuth-Morris-Pratt (KMP) algorithm. It’s quite easy to implement, when you understand it. In addition, its time complexity is quite good and can be defined as O(n). In this algorithm, we simply go through all letters in a given string and compare them with searched string. When position of searched string reaches length of searched string, we can assume, that our string was found. If two compared letters are different, we set position of searched string to zero and start new search from the next position after which we started searching process before. It’s quite good described on Wikipedia with some pseudo-code. You can also take a look at my code in Java available below, which I’ve written just for practice.\npublic class Main { public static void main(String args[]) { String givenString = \"ABC ABCDAB ABCDABCDABDE\"; String searchedString = \"ABCDABD\"; int givenStringLetterPosition = 0; int searchedStringLetterPosition = 0; int foundAt = -1; while (givenStringLetterPosition \u003c givenString.length()) { if (givenString.charAt(givenStringLetterPosition) == searchedString.charAt(searchedStringLetterPosition)) { if(searchedStringLetterPosition == 0) { foundAt = givenStringLetterPosition; } searchedStringLetterPosition++; givenStringLetterPosition++; if(searchedStringLetterPosition == searchedString.length()) { System.out.println(\"String found at \" + foundAt + \" position.\"); break; } } else { searchedStringLetterPosition = 0; foundAt++; givenStringLetterPosition = foundAt; if(givenString.length() == givenStringLetterPosition) { System.out.println(\"String was not found.\"); break; } } } } } Result of the execution of this program should be as follows:\nString found at 15 position. Please note, that we count position of the letter from zero like in the most cases in Computer Science.\n","wordCount":"320","inLanguage":"en","datePublished":"2015-07-22T13:03:00Z","dateModified":"2015-07-22T13:03:00Z","author":{"@type":"Person","name":"Piotr Wittchen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wittchen.io/notes/searching-word-in-a-string-with-kmp-algorithm/"},"publisher":{"@type":"Organization","name":"Piotr Wittchen","logo":{"@type":"ImageObject","url":"https://wittchen.io/favicon.ico"}}}</script><script defer data-website-id=dfid_D4sN47CVgrrCRR7KCciN3 data-domain=wittchen.io src=https://datafa.st/js/script.js></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wittchen.io/ accesskey=h title="Piotr Wittchen (Alt + H)">Piotr Wittchen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><button id=menu-toggle class=menu-toggle aria-label="Toggle menu" aria-expanded=false>
<svg class="hamburger-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
<svg class="close-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button><ul id=menu><li><a href=https://wittchen.io/about/ title=about><span>about</span></a></li><li><a href=https://wittchen.io/notes/ title=notes><span>notes</span></a></li><li><a href=https://wittchen.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://wittchen.io/talks/ title=talks><span>talks</span></a></li><li><a href=https://wittchen.io/projects/ title=projects><span>projects</span></a></li><li><a href=https://wittchen.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wittchen.io/>Home</a>&nbsp;»&nbsp;<a href=https://wittchen.io/notes/>Notes</a></div><h1 class="post-title entry-hint-parent">Searching word in a string with KMP algorithm</h1><div class=post-meta><span title='2015-07-22 13:03:00 +0000 UTC'>July 22, 2015</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;320 words&nbsp;·&nbsp;Piotr Wittchen&nbsp;|&nbsp;<a href=https://github.com/pwittchen/wittchen.io/blob/master/content/notes/searching-word-in-a-string-with-kmp-algorithm.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Sometimes it&rsquo;s good to revise some algorithms and try to implement them in order to get to know, how the built-in functions of high level programming languages actually works. One of the popular problems is <a href=http://en.wikipedia.org/wiki/String_searching_algorithm>string searching</a>. We have many approaches to solve this problem. For example:</p><ul><li>Naive string search algorithm</li><li>Rabin-Karp string search algorithm</li><li>Finite-state automaton based search</li><li>Knuth-Morris-Pratt algorithm</li><li>Boyer-Moore string search algorithm</li><li>Bitap algorithm</li></ul><p>This time, I&rsquo;ve decided to focus on <a href=http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm>Knuth-Morris-Pratt (KMP) algorithm</a>. It&rsquo;s quite easy to implement, when you understand it. In addition, its time complexity is quite good and can be defined as <em>O(n)</em>. In this algorithm, we simply go through all letters in a given string and compare them with searched string. When position of searched string reaches length of searched string, we can assume, that our string was found. If two compared letters are different, we set position of searched string to zero and start new search from the next position after which we started searching process before. It&rsquo;s quite good described on <a href=http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm>Wikipedia</a> with some pseudo-code. You can also take a look at my code in Java available below, which I&rsquo;ve written just for practice.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Main</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>args</span><span class=o>[]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>givenString</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;ABC ABCDAB ABCDABCDABDE&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>searchedString</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;ABCDABD&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>givenStringLetterPosition</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>searchedStringLetterPosition</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>foundAt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>-</span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>givenStringLetterPosition</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>givenString</span><span class=p>.</span><span class=na>length</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>givenString</span><span class=p>.</span><span class=na>charAt</span><span class=p>(</span><span class=n>givenStringLetterPosition</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>searchedString</span><span class=p>.</span><span class=na>charAt</span><span class=p>(</span><span class=n>searchedStringLetterPosition</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=p>(</span><span class=n>searchedStringLetterPosition</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>foundAt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>givenStringLetterPosition</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>searchedStringLetterPosition</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>givenStringLetterPosition</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=p>(</span><span class=n>searchedStringLetterPosition</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>searchedString</span><span class=p>.</span><span class=na>length</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;String found at &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>foundAt</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; position.&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>searchedStringLetterPosition</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>foundAt</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>givenStringLetterPosition</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>foundAt</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=p>(</span><span class=n>givenString</span><span class=p>.</span><span class=na>length</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>givenStringLetterPosition</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;String was not found.&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Result of the execution of this program should be as follows:</p><pre tabindex=0><code>String found at 15 position.
</code></pre><p>Please note, that we count position of the letter from zero like in the most cases in Computer Science.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wittchen.io/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=https://wittchen.io/notes/routing-internet-via-ssh-tunnel-on-raspberry-pi/><span class=title>« Prev</span><br><span>Routing internet via SSH tunnel on Raspberry Pi</span>
</a><a class=next href=https://wittchen.io/notes/releasing-weather-icon-view-1-for-android/><span class=title>Next »</span><br><span>Releasing Weather Icon View v. 1.0.0 for Android</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://wittchen.io/>Piotr Wittchen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a> (modified | inspired by <a href=https://ui.shadcn.com/ rel=noopener target=_blank>shadcn-ui</a>)</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){const e=document.querySelector(".header");if(!e)return;function t(){window.scrollY>10?e.classList.add("scrolled"):e.classList.remove("scrolled")}window.addEventListener("scroll",t,{passive:!0}),t()})(),function(){const t=document.getElementById("menu-toggle"),e=document.getElementById("menu");if(!t||!e)return;function s(){const n=t.getAttribute("aria-expanded")==="true";t.setAttribute("aria-expanded",!n),e.classList.toggle("menu-open"),document.body.classList.toggle("menu-open"),n||window.scrollTo(0,0)}function n(){t.setAttribute("aria-expanded","false"),e.classList.remove("menu-open"),document.body.classList.remove("menu-open")}t.addEventListener("click",s),e.querySelectorAll("a").forEach(e=>{e.addEventListener("click",n)}),document.addEventListener("keydown",function(t){t.key==="Escape"&&e.classList.contains("menu-open")&&n()}),window.addEventListener("resize",function(){window.innerWidth>768&&e.classList.contains("menu-open")&&n()})}()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>