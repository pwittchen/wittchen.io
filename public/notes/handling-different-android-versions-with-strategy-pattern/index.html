<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Handling different Android versions with strategy pattern | Piotr Wittchen</title><meta name=keywords content="android"><meta name=description content="When we&rsquo;re developing Android apps, we have to remember that different users have different versions of the Android OS. Unfortunately, not all of them has the newest version of the system and some of them have older devices with older systems. Some of these devices may be even unsupported because e.g. Google supports their devices like Nexus and Pixel for only 2 years. When we want to reach as many users as possible and make the app available for almost everyone, we have to handle different Android versions. One of the solutions for that problem is strategy design pattern (it&rsquo;s also called Policy in Domain-Driven Design). I&rsquo;m developing an Android open-source library called ReactiveNetwork, which is used for monitoring connectivity with the network in the system. Network monitoring strategies vary between different versions of Android and I wanted to choose an appropriate strategy for appropriate Android version. To do so, I&rsquo;ve created NetworkObservingStrategy interface:"><meta name=author content="Piotr Wittchen"><link rel=canonical href=https://wittchen.io/notes/handling-different-android-versions-with-strategy-pattern/><link crossorigin=anonymous href=/assets/css/stylesheet.8a0fc40893e283b361cf6ae55669e07865a970fc8dae85ca85851937c57f2912.css integrity="sha256-ig/ECJPig7Nhz2rlVmngeGWpcPyNroXKhYUZN8V/KRI=" rel="preload stylesheet" as=style><link rel=icon href=https://wittchen.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wittchen.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wittchen.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wittchen.io/apple-touch-icon.png><link rel=mask-icon href=https://wittchen.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://wittchen.io/notes/handling-different-android-versions-with-strategy-pattern/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wittchen.io/notes/handling-different-android-versions-with-strategy-pattern/"><meta property="og:site_name" content="Piotr Wittchen"><meta property="og:title" content="Handling different Android versions with strategy pattern"><meta property="og:description" content="When we’re developing Android apps, we have to remember that different users have different versions of the Android OS. Unfortunately, not all of them has the newest version of the system and some of them have older devices with older systems. Some of these devices may be even unsupported because e.g. Google supports their devices like Nexus and Pixel for only 2 years. When we want to reach as many users as possible and make the app available for almost everyone, we have to handle different Android versions. One of the solutions for that problem is strategy design pattern (it’s also called Policy in Domain-Driven Design). I’m developing an Android open-source library called ReactiveNetwork, which is used for monitoring connectivity with the network in the system. Network monitoring strategies vary between different versions of Android and I wanted to choose an appropriate strategy for appropriate Android version. To do so, I’ve created NetworkObservingStrategy interface:"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:published_time" content="2017-03-26T22:39:00+00:00"><meta property="article:modified_time" content="2017-03-26T22:39:00+00:00"><meta property="article:tag" content="Android"><meta name=twitter:card content="summary"><meta name=twitter:title content="Handling different Android versions with strategy pattern"><meta name=twitter:description content="When we&rsquo;re developing Android apps, we have to remember that different users have different versions of the Android OS. Unfortunately, not all of them has the newest version of the system and some of them have older devices with older systems. Some of these devices may be even unsupported because e.g. Google supports their devices like Nexus and Pixel for only 2 years. When we want to reach as many users as possible and make the app available for almost everyone, we have to handle different Android versions. One of the solutions for that problem is strategy design pattern (it&rsquo;s also called Policy in Domain-Driven Design). I&rsquo;m developing an Android open-source library called ReactiveNetwork, which is used for monitoring connectivity with the network in the system. Network monitoring strategies vary between different versions of Android and I wanted to choose an appropriate strategy for appropriate Android version. To do so, I&rsquo;ve created NetworkObservingStrategy interface:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://wittchen.io/notes/"},{"@type":"ListItem","position":2,"name":"Handling different Android versions with strategy pattern","item":"https://wittchen.io/notes/handling-different-android-versions-with-strategy-pattern/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Handling different Android versions with strategy pattern","name":"Handling different Android versions with strategy pattern","description":"When we\u0026rsquo;re developing Android apps, we have to remember that different users have different versions of the Android OS. Unfortunately, not all of them has the newest version of the system and some of them have older devices with older systems. Some of these devices may be even unsupported because e.g. Google supports their devices like Nexus and Pixel for only 2 years. When we want to reach as many users as possible and make the app available for almost everyone, we have to handle different Android versions. One of the solutions for that problem is strategy design pattern (it\u0026rsquo;s also called Policy in Domain-Driven Design). I\u0026rsquo;m developing an Android open-source library called ReactiveNetwork, which is used for monitoring connectivity with the network in the system. Network monitoring strategies vary between different versions of Android and I wanted to choose an appropriate strategy for appropriate Android version. To do so, I\u0026rsquo;ve created NetworkObservingStrategy interface:\n","keywords":["android"],"articleBody":"When we’re developing Android apps, we have to remember that different users have different versions of the Android OS. Unfortunately, not all of them has the newest version of the system and some of them have older devices with older systems. Some of these devices may be even unsupported because e.g. Google supports their devices like Nexus and Pixel for only 2 years. When we want to reach as many users as possible and make the app available for almost everyone, we have to handle different Android versions. One of the solutions for that problem is strategy design pattern (it’s also called Policy in Domain-Driven Design). I’m developing an Android open-source library called ReactiveNetwork, which is used for monitoring connectivity with the network in the system. Network monitoring strategies vary between different versions of Android and I wanted to choose an appropriate strategy for appropriate Android version. To do so, I’ve created NetworkObservingStrategy interface:\npublic interface NetworkObservingStrategy { Observable observeNetworkConnectivity(final Context context); void onError(final String message, final Exception exception); } This interface can have many implementations like LollipopNetworkObservingStrategy, PreLollipopNetworkObservingStrategy and MarshmallowNetworkObservingStrategy. Morever, more implementations can be added in the future. After that, we can choose a valid strategy for the concrete version of the system:\npublic static Observable\u003cConnectivity\u003e observeNetworkConnectivity(final Context context) { final NetworkObservingStrategy strategy; if (Preconditions.isAtLeastAndroidMarshmallow()) { strategy = new MarshmallowNetworkObservingStrategy(); } else if (Preconditions.isAtLeastAndroidLollipop()) { strategy = new LollipopNetworkObservingStrategy(); } else { strategy = new PreLollipopNetworkObservingStrategy(); } return strategy.observeNetworkConnectivity(context); } That’s it. Now, we have the separate code working for Android M, L and all devices with system version lower than L. This approach can also be applied to other areas.\n","wordCount":"273","inLanguage":"en","datePublished":"2017-03-26T22:39:00Z","dateModified":"2017-03-26T22:39:00Z","author":{"@type":"Person","name":"Piotr Wittchen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wittchen.io/notes/handling-different-android-versions-with-strategy-pattern/"},"publisher":{"@type":"Organization","name":"Piotr Wittchen","logo":{"@type":"ImageObject","url":"https://wittchen.io/favicon.ico"}}}</script><script defer data-website-id=dfid_D4sN47CVgrrCRR7KCciN3 data-domain=wittchen.io src=https://datafa.st/js/script.js></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wittchen.io/ accesskey=h title="Piotr Wittchen (Alt + H)">Piotr Wittchen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wittchen.io/notes/ title=notes><span>notes</span></a></li><li><a href=https://wittchen.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://wittchen.io/talks/ title=talks><span>talks</span></a></li><li><a href=https://wittchen.io/projects/ title=projects><span>projects</span></a></li><li><a href=https://wittchen.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://wittchen.io/contact/ title=contact><span>contact</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wittchen.io/>Home</a>&nbsp;»&nbsp;<a href=https://wittchen.io/notes/>Notes</a></div><h1 class="post-title entry-hint-parent">Handling different Android versions with strategy pattern</h1><div class=post-meta><span title='2017-03-26 22:39:00 +0000 UTC'>March 26, 2017</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;273 words&nbsp;·&nbsp;Piotr Wittchen&nbsp;|&nbsp;<a href=https://github.com/pwittchen/wittchen.io/blob/master/content/notes/handling-different-android-versions-with-strategy-pattern.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>When we&rsquo;re developing Android apps, we have to remember that different users have different versions of the Android OS. Unfortunately, not all of them has the newest version of the system and some of them have older devices with older systems. Some of these devices may be even unsupported because e.g. Google supports their devices like Nexus and Pixel for only 2 years. When we want to reach as many users as possible and make the app available for almost everyone, we have to handle different Android versions. One of the solutions for that problem is <strong>strategy design pattern</strong> (it&rsquo;s also called Policy in Domain-Driven Design). I&rsquo;m developing an Android open-source library called <a href=https://github.com/pwittchen/ReactiveNetwork>ReactiveNetwork</a>, which is used for monitoring connectivity with the network in the system. Network monitoring strategies vary between different versions of Android and I wanted to choose an appropriate strategy for appropriate Android version. To do so, I&rsquo;ve created <code>NetworkObservingStrategy</code> interface:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>interface</span> <span class=nc>NetworkObservingStrategy</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Observable</span><span class=w> </span><span class=nf>observeNetworkConnectivity</span><span class=p>(</span><span class=kd>final</span><span class=w> </span><span class=n>Context</span><span class=w> </span><span class=n>context</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kt>void</span><span class=w> </span><span class=nf>onError</span><span class=p>(</span><span class=kd>final</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>message</span><span class=p>,</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=n>exception</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>This interface can have many implementations like <code>LollipopNetworkObservingStrategy</code>, <code>PreLollipopNetworkObservingStrategy</code> and <code>MarshmallowNetworkObservingStrategy</code>. Morever, more implementations can be added in the future. After that, we can choose a valid strategy for the concrete version of the system:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Observable</span><span class=o>&lt;</span><span class=n>Connectivity</span><span class=o>&gt;</span><span class=w> </span><span class=nf>observeNetworkConnectivity</span><span class=p>(</span><span class=kd>final</span><span class=w> </span><span class=n>Context</span><span class=w> </span><span class=n>context</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>final</span><span class=w> </span><span class=n>NetworkObservingStrategy</span><span class=w> </span><span class=n>strategy</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>Preconditions</span><span class=p>.</span><span class=na>isAtLeastAndroidMarshmallow</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>strategy</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>MarshmallowNetworkObservingStrategy</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>Preconditions</span><span class=p>.</span><span class=na>isAtLeastAndroidLollipop</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>strategy</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>LollipopNetworkObservingStrategy</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>strategy</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>PreLollipopNetworkObservingStrategy</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>strategy</span><span class=p>.</span><span class=na>observeNetworkConnectivity</span><span class=p>(</span><span class=n>context</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>That&rsquo;s it. Now, we have the separate code working for Android M, L and all devices with system version lower than L. This approach can also be applied to other areas.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wittchen.io/tags/android/>Android</a></li></ul><nav class=paginav><a class=prev href=https://wittchen.io/notes/how-to-make-open-source-projects-which-people-want-to-use/><span class=title>« Prev</span><br><span>How to make open-source projects, which people want to use</span>
</a><a class=next href=https://wittchen.io/notes/review-your-changes-before-the-commit/><span class=title>Next »</span><br><span>Review your changes in the code before the commit</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://wittchen.io/>Piotr Wittchen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a> (modified | inspired by <a href=https://ui.shadcn.com/ rel=noopener target=_blank>shadcn-ui</a>)</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){const e=document.querySelector(".header");if(!e)return;function t(){window.scrollY>10?e.classList.add("scrolled"):e.classList.remove("scrolled")}window.addEventListener("scroll",t,{passive:!0}),t()})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>