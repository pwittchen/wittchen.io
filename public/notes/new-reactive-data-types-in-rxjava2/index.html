<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>New reactive data types in RxJava2 | Piotr Wittchen</title><meta name=keywords content="java,rxjava"><meta name=description content="Introduction
I&rsquo;m still exploring reactive programming world and RxJava library. Recently, I&rsquo;ve migrated a few of my open-source libraries from RxJava1 to RxJava2 and written yet another project in RxJava2 from the beginning. Nevertheless, I&rsquo;m still learning this library and its concept. It&rsquo;s very wide topic. In RxJava1 we simply had one reactive data type called Observable. In RxJava2, we have more data types like Observable, Flowable, Single, Maybe & Completable. In this article, I&rsquo;ll briefly explain their purpose and tell you when to use which. The general idea behind these types is code semantics. We should tell consumer of our code, what he or she can expect from our API. Introducing more reactive data types can increase readability and stability of our code base."><meta name=author content="Piotr Wittchen"><link rel=canonical href=https://wittchen.io/notes/new-reactive-data-types-in-rxjava2/><link crossorigin=anonymous href=/assets/css/stylesheet.ce07c2a628121ab9051d703ded1d918162d348e5c03783b702262170087c359e.css integrity="sha256-zgfCpigSGrkFHXA97R2RgWLTSOXAN4O3AiYhcAh8NZ4=" rel="preload stylesheet" as=style><link rel=icon href=https://wittchen.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wittchen.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wittchen.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wittchen.io/apple-touch-icon.png><link rel=mask-icon href=https://wittchen.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://wittchen.io/notes/new-reactive-data-types-in-rxjava2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wittchen.io/notes/new-reactive-data-types-in-rxjava2/"><meta property="og:site_name" content="Piotr Wittchen"><meta property="og:title" content="New reactive data types in RxJava2"><meta property="og:description" content="Introduction I’m still exploring reactive programming world and RxJava library. Recently, I’ve migrated a few of my open-source libraries from RxJava1 to RxJava2 and written yet another project in RxJava2 from the beginning. Nevertheless, I’m still learning this library and its concept. It’s very wide topic. In RxJava1 we simply had one reactive data type called Observable. In RxJava2, we have more data types like Observable, Flowable, Single, Maybe & Completable. In this article, I’ll briefly explain their purpose and tell you when to use which. The general idea behind these types is code semantics. We should tell consumer of our code, what he or she can expect from our API. Introducing more reactive data types can increase readability and stability of our code base."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:published_time" content="2017-05-31T17:49:00+00:00"><meta property="article:modified_time" content="2017-05-31T17:49:00+00:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="Rxjava"><meta name=twitter:card content="summary"><meta name=twitter:title content="New reactive data types in RxJava2"><meta name=twitter:description content="Introduction
I&rsquo;m still exploring reactive programming world and RxJava library. Recently, I&rsquo;ve migrated a few of my open-source libraries from RxJava1 to RxJava2 and written yet another project in RxJava2 from the beginning. Nevertheless, I&rsquo;m still learning this library and its concept. It&rsquo;s very wide topic. In RxJava1 we simply had one reactive data type called Observable. In RxJava2, we have more data types like Observable, Flowable, Single, Maybe & Completable. In this article, I&rsquo;ll briefly explain their purpose and tell you when to use which. The general idea behind these types is code semantics. We should tell consumer of our code, what he or she can expect from our API. Introducing more reactive data types can increase readability and stability of our code base."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://wittchen.io/notes/"},{"@type":"ListItem","position":2,"name":"New reactive data types in RxJava2","item":"https://wittchen.io/notes/new-reactive-data-types-in-rxjava2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"New reactive data types in RxJava2","name":"New reactive data types in RxJava2","description":"Introduction I\u0026rsquo;m still exploring reactive programming world and RxJava library. Recently, I\u0026rsquo;ve migrated a few of my open-source libraries from RxJava1 to RxJava2 and written yet another project in RxJava2 from the beginning. Nevertheless, I\u0026rsquo;m still learning this library and its concept. It\u0026rsquo;s very wide topic. In RxJava1 we simply had one reactive data type called Observable. In RxJava2, we have more data types like Observable, Flowable, Single, Maybe \u0026amp; Completable. In this article, I\u0026rsquo;ll briefly explain their purpose and tell you when to use which. The general idea behind these types is code semantics. We should tell consumer of our code, what he or she can expect from our API. Introducing more reactive data types can increase readability and stability of our code base.\n","keywords":["java","rxjava"],"articleBody":"Introduction I’m still exploring reactive programming world and RxJava library. Recently, I’ve migrated a few of my open-source libraries from RxJava1 to RxJava2 and written yet another project in RxJava2 from the beginning. Nevertheless, I’m still learning this library and its concept. It’s very wide topic. In RxJava1 we simply had one reactive data type called Observable. In RxJava2, we have more data types like Observable, Flowable, Single, Maybe \u0026 Completable. In this article, I’ll briefly explain their purpose and tell you when to use which. The general idea behind these types is code semantics. We should tell consumer of our code, what he or she can expect from our API. Introducing more reactive data types can increase readability and stability of our code base.\nObservable Observable is basically the same Reactive type, we had in RxJava1. It doesn’t have backpressure support. We should use Observable, when:\nour data source emits less than 1000 items, so there’s practically no chance of occurring OutOfMemoryException we are working with GUI events, which usually don’t occurs very often and don’t have to be backpressured we are working with synchronous code on legacy JVM like Java 1.6 and we want to have streams features like in Java 8 Flowable Flowable type has very similar semantics to Observable. We can operate on Flowable streams with map, flatmap, filter, etc. in the same way as on the Observable type. The main difference is backpressure support. We should use Flowable when we are:\ndealing with 10k+ elements in a stream dealing with frequent events (e.g. sensors readings) reading/parsing files from disk reading values from database through JDBC using network/streaming I/O reading/writing to many blocking or pull-based data sources To learn more, read note about Observable vs. Flowable on wiki of RxJava2 on GitHub.\nSingle Single reactive type has been redesigned from scratch in RxJava 2. It’s designed to handle just one event in an asynchronous manner. Good application of this type is single HTTP request when we expect just one response or error and nothing else. It can emit on onSuccess (single value) or onError event (error).\nMaybe Maybe represents a deferred computation and emission of a maybe value or exception. Maybe is a wrapper around an operation/event that may have either:\nA single result Error No result Just take a look at the scheme. The interface of the main consumer of this type have the following methods: onSuccess, onError, onComplete. Conceptually, Maybe is a union of Single and Completable providing the means to capture an emission pattern where there could be 0 or 1 item or an error signaled by some reactive source.\nCompletable Completable type can be used when we have an Observable that we don’t care about the value resulted from the operation (result is void). It handles only onComplete and onError events. Conceptually, Maybe is a union of Single and Completable providing the means to capture an emission pattern where there could be 0 or 1 item or an error signalled by some reactive source. Read more about Maybe type on RxJava wiki.\nSummary As we can see, RxJava2 gives us new types, which can help explain our intentions more clearly. We can adjust concrete type to the specific situation. In addition, we can use backpressure for the data sources, which emit a lot of elements to make our projects more robust and stable. Last, but not least RxJava2 is compatible with Reactive Streams API, which is going to be part of the Java 9 specification.\nReferences JavaDoc for RxJava2 What’s diffferent in 2.0? StackOverflow Thread: What is the difference between Observable, Completable and Single in RxJava? StackOverflow Thread: What’s the difference between RxJava2’s Maybe and Optional? Clearer RxJava intentions with Single and Completable Blog of Akarnokd (one of the main RxJava contributors) RxJava GitHub repository ReactiveX Reactive Programming with RxJava (O’Reilly Media Book) Reactive Streams Reactive Manifesto ","wordCount":"645","inLanguage":"en","datePublished":"2017-05-31T17:49:00Z","dateModified":"2017-05-31T17:49:00Z","author":{"@type":"Person","name":"Piotr Wittchen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wittchen.io/notes/new-reactive-data-types-in-rxjava2/"},"publisher":{"@type":"Organization","name":"Piotr Wittchen","logo":{"@type":"ImageObject","url":"https://wittchen.io/favicon.ico"}}}</script><script defer data-website-id=dfid_D4sN47CVgrrCRR7KCciN3 data-domain=wittchen.io src=https://datafa.st/js/script.js></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wittchen.io/ accesskey=h title="Piotr Wittchen (Alt + H)">Piotr Wittchen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><button id=menu-toggle class=menu-toggle aria-label="Toggle menu" aria-expanded=false>
<svg class="hamburger-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
<svg class="close-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button><ul id=menu><li><a href=https://wittchen.io/about/ title=about><span>about</span></a></li><li><a href=https://wittchen.io/notes/ title=notes><span>notes</span></a></li><li><a href=https://wittchen.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://wittchen.io/talks/ title=talks><span>talks</span></a></li><li><a href=https://wittchen.io/projects/ title=projects><span>projects</span></a></li><li><a href=https://wittchen.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wittchen.io/>Home</a>&nbsp;»&nbsp;<a href=https://wittchen.io/notes/>Notes</a></div><h1 class="post-title entry-hint-parent">New reactive data types in RxJava2</h1><div class=post-meta><span title='2017-05-31 17:49:00 +0000 UTC'>May 31, 2017</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;645 words&nbsp;·&nbsp;Piotr Wittchen&nbsp;|&nbsp;<a href=https://github.com/pwittchen/wittchen.io/blob/master/content/notes/new-reactive-data-types-in-rxjava2.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>I&rsquo;m still exploring reactive programming world and RxJava library. Recently, I&rsquo;ve migrated a few of my open-source libraries from RxJava1 to RxJava2 and written yet another project in RxJava2 from the beginning. Nevertheless, I&rsquo;m still learning this library and its concept. It&rsquo;s very wide topic. In RxJava1 we simply had one reactive data type called <code>Observable</code>. In RxJava2, we have more data types like <code>Observable</code>, <code>Flowable</code>, <code>Single</code>, <code>Maybe</code> & <code>Completable</code>. In this article, I&rsquo;ll briefly explain their purpose and tell you when to use which. The general idea behind these types is code semantics. We should tell consumer of our code, what he or she can expect from our API. Introducing more reactive data types can increase readability and stability of our code base.</p><h2 id=observable><a href=http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html>Observable</a><a hidden class=anchor aria-hidden=true href=#observable>#</a></h2><p><code>Observable</code> is basically the same Reactive type, we had in RxJava1. <strong>It doesn&rsquo;t have <a href="https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#backpressure">backpressure</a> support</strong>. We should use <code>Observable</code>, when:</p><ul><li>our data source emits less than 1000 items, so there&rsquo;s practically no chance of occurring <code>OutOfMemoryException</code></li><li>we are working with GUI events, which usually don&rsquo;t occurs very often and don&rsquo;t have to be backpressured</li><li>we are working with synchronous code on legacy JVM like Java 1.6 and we want to have streams features like in Java 8</li></ul><p><img alt=Observable loading=lazy src=/posts/2017/new-reactive-data-types-in-rxjava2/observable-644x319.png></p><h2 id=flowable><a href=http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html>Flowable</a><a hidden class=anchor aria-hidden=true href=#flowable>#</a></h2><p><code>Flowable</code> type has very similar semantics to <code>Observable</code>. We can operate on <code>Flowable</code> streams with map, flatmap, filter, etc. in the same way as on the <code>Observable</code> type. The main difference is <strong><a href="https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#backpressure">backpressure</a> support</strong>. We should use <code>Flowable</code> when we are:</p><ul><li>dealing with 10k+ elements in a stream</li><li>dealing with frequent events (e.g. sensors readings)</li><li>reading/parsing files from disk</li><li>reading values from database through JDBC</li><li>using network/streaming I/O</li><li>reading/writing to many blocking or pull-based data sources</li></ul><p>To learn more, read note about <a href="https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#observable-and-flowable">Observable vs. Flowable</a> on wiki of RxJava2 on GitHub.</p><h2 id=single><a href=http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Single.html>Single</a><a hidden class=anchor aria-hidden=true href=#single>#</a></h2><p><code>Single</code> reactive type has been redesigned from scratch in RxJava 2. It&rsquo;s designed to handle just one event in an asynchronous manner. Good application of this type is single HTTP request when we expect just one response or error and nothing else. It can emit on <code>onSuccess</code> (single value) or <code>onError</code> event (error).</p><p><img alt=Single loading=lazy src=/posts/2017/new-reactive-data-types-in-rxjava2/single-644x303.png></p><h2 id=maybe><a href=http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Maybe.html>Maybe</a><a hidden class=anchor aria-hidden=true href=#maybe>#</a></h2><p><code>Maybe</code> represents a deferred computation and emission of a maybe value or exception. <code>Maybe</code> is a wrapper around an operation/event that may have either:</p><ul><li>A single result</li><li>Error</li><li>No result</li></ul><p>Just take a look at the scheme. The interface of the main consumer of this type have the following methods: <code>onSuccess</code>, <code>onError</code>, <code>onComplete</code>. Conceptually, <code>Maybe</code> is a union of <code>Single</code> and <code>Completable</code> providing the means to capture an emission pattern where there could be 0 or 1 item or an error signaled by some reactive source.</p><p><img alt=Maybe loading=lazy src=/posts/2017/new-reactive-data-types-in-rxjava2/maybe.png></p><h2 id=completable><a href=http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Completable.html>Completable</a><a hidden class=anchor aria-hidden=true href=#completable>#</a></h2><p><code>Completable</code> type can be used when we have an <code>Observable</code> that <strong>we don&rsquo;t care about the value resulted from the operation</strong> (result is void). It handles only <code>onComplete</code> and <code>onError</code> events. Conceptually, <code>Maybe</code> is a union of <code>Single</code> and <code>Completable</code> providing the means to capture an emission pattern where there could be 0 or 1 item or an error signalled by some reactive source. Read more about <code>Maybe</code> type on <a href=https://github.com/ReactiveX/RxJava/wiki/What%27s-different-in-2.0#maybe>RxJava wiki</a>.</p><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>As we can see, RxJava2 gives us new types, which can help explain our intentions more clearly. We can adjust concrete type to the specific situation. In addition, we can use backpressure for the data sources, which emit a lot of elements to make our projects more robust and stable. Last, but not least RxJava2 is compatible with <a href=http://reactive-streams.org>Reactive Streams</a> API, which is going to be part of the Java 9 specification.</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=http://reactivex.io/RxJava/2.x/javadoc/>JavaDoc for RxJava2</a></li><li><a href="https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0">What&rsquo;s diffferent in 2.0?</a></li><li><a href=https://stackoverflow.com/questions/42757924/what-is-the-difference-between-observable-completable-and-single-in-rxjava>StackOverflow Thread: What is the difference between Observable, Completable and Single in RxJava?</a></li><li><a href=https://stackoverflow.com/questions/40439579/whats-the-difference-between-rxjava2s-maybe-and-optional>StackOverflow Thread: What&rsquo;s the difference between RxJava2&rsquo;s Maybe and Optional?</a></li><li><a href=https://android.jlelse.eu/making-your-rxjava-intentions-clearer-with-single-and-completable-f064d98d53a8>Clearer RxJava intentions with Single and Completable</a></li><li><a href=http://akarnokd.blogspot.com/>Blog of Akarnokd (one of the main RxJava contributors)</a></li><li><a href=https://github.com/ReactiveX/RxJava>RxJava GitHub repository</a></li><li><a href=http://reactivex.io/>ReactiveX</a></li><li><a href=http://shop.oreilly.com/product/0636920042228.do>Reactive Programming with RxJava (O&rsquo;Reilly Media Book)</a></li><li><a href=http://www.reactive-streams.org/>Reactive Streams</a></li><li><a href=http://www.reactivemanifesto.org/>Reactive Manifesto</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://wittchen.io/tags/java/>Java</a></li><li><a href=https://wittchen.io/tags/rxjava/>Rxjava</a></li></ul><nav class=paginav><a class=prev href=https://wittchen.io/notes/release-of-prefser-210-with-rxjava2/><span class=title>« Prev</span><br><span>Release of prefser v. 2.1.0 with RxJava2 support</span>
</a><a class=next href=https://wittchen.io/notes/introducing-yaas-java-sdk/><span class=title>Next »</span><br><span>Introducing YaaS Java SDK</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://wittchen.io/>Piotr Wittchen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a> · theme modifications inspired by <a href=https://ui.shadcn.com/ rel=noopener target=_blank>shadcn-ui</a> · <a href=https://github.com/pwittchen/wittchen.io rel=noopener target=_blank>open-source</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){const e=document.querySelector(".header");if(!e)return;function t(){window.scrollY>10?e.classList.add("scrolled"):e.classList.remove("scrolled")}window.addEventListener("scroll",t,{passive:!0}),t()})(),function(){const t=document.getElementById("menu-toggle"),e=document.getElementById("menu");if(!t||!e)return;function s(){const n=t.getAttribute("aria-expanded")==="true";t.setAttribute("aria-expanded",!n),e.classList.toggle("menu-open"),document.body.classList.toggle("menu-open"),n||window.scrollTo(0,0)}function n(){t.setAttribute("aria-expanded","false"),e.classList.remove("menu-open"),document.body.classList.remove("menu-open")}t.addEventListener("click",s),e.querySelectorAll("a").forEach(e=>{e.addEventListener("click",n)}),document.addEventListener("keydown",function(t){t.key==="Escape"&&e.classList.contains("menu-open")&&n()}),window.addEventListener("resize",function(){window.innerWidth>768&&e.classList.contains("menu-open")&&n()})}()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>