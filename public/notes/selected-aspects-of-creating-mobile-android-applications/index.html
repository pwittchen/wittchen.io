<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Selected aspects of creating mobile Android applications | Piotr Wittchen</title><meta name=keywords content="android"><meta name=description content="During the development of mobile applications, we should adjust our point of view to the specific projects we are working with. Applications for mobile devices are different than desktop or web applications. They have their own lifecycle, work on various devices with different screen resolutions. They have to work on devices with limited memory, clock rate of the CPU and battery life. In addition, these applications often have to be able to work without an Internet connection and their user interface has to be simple and well-designed due to smaller screen of a typical smartphone."><meta name=author content="Piotr Wittchen"><link rel=canonical href=https://wittchen.io/notes/selected-aspects-of-creating-mobile-android-applications/><link crossorigin=anonymous href=/assets/css/stylesheet.ce07c2a628121ab9051d703ded1d918162d348e5c03783b702262170087c359e.css integrity="sha256-zgfCpigSGrkFHXA97R2RgWLTSOXAN4O3AiYhcAh8NZ4=" rel="preload stylesheet" as=style><link rel=icon href=https://wittchen.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wittchen.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wittchen.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wittchen.io/apple-touch-icon.png><link rel=mask-icon href=https://wittchen.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://wittchen.io/notes/selected-aspects-of-creating-mobile-android-applications/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wittchen.io/notes/selected-aspects-of-creating-mobile-android-applications/"><meta property="og:site_name" content="Piotr Wittchen"><meta property="og:title" content="Selected aspects of creating mobile Android applications"><meta property="og:description" content="During the development of mobile applications, we should adjust our point of view to the specific projects we are working with. Applications for mobile devices are different than desktop or web applications. They have their own lifecycle, work on various devices with different screen resolutions. They have to work on devices with limited memory, clock rate of the CPU and battery life. In addition, these applications often have to be able to work without an Internet connection and their user interface has to be simple and well-designed due to smaller screen of a typical smartphone."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:published_time" content="2014-04-07T17:04:00+00:00"><meta property="article:modified_time" content="2014-04-07T17:04:00+00:00"><meta property="article:tag" content="Android"><meta name=twitter:card content="summary"><meta name=twitter:title content="Selected aspects of creating mobile Android applications"><meta name=twitter:description content="During the development of mobile applications, we should adjust our point of view to the specific projects we are working with. Applications for mobile devices are different than desktop or web applications. They have their own lifecycle, work on various devices with different screen resolutions. They have to work on devices with limited memory, clock rate of the CPU and battery life. In addition, these applications often have to be able to work without an Internet connection and their user interface has to be simple and well-designed due to smaller screen of a typical smartphone."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://wittchen.io/notes/"},{"@type":"ListItem","position":2,"name":"Selected aspects of creating mobile Android applications","item":"https://wittchen.io/notes/selected-aspects-of-creating-mobile-android-applications/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Selected aspects of creating mobile Android applications","name":"Selected aspects of creating mobile Android applications","description":"During the development of mobile applications, we should adjust our point of view to the specific projects we are working with. Applications for mobile devices are different than desktop or web applications. They have their own lifecycle, work on various devices with different screen resolutions. They have to work on devices with limited memory, clock rate of the CPU and battery life. In addition, these applications often have to be able to work without an Internet connection and their user interface has to be simple and well-designed due to smaller screen of a typical smartphone.\n","keywords":["android"],"articleBody":"During the development of mobile applications, we should adjust our point of view to the specific projects we are working with. Applications for mobile devices are different than desktop or web applications. They have their own lifecycle, work on various devices with different screen resolutions. They have to work on devices with limited memory, clock rate of the CPU and battery life. In addition, these applications often have to be able to work without an Internet connection and their user interface has to be simple and well-designed due to smaller screen of a typical smartphone.\nAs we can see, there is a lot of limitations, but there are also plenty of new possibilities. We can use GPS and create location-aware applications. We can access Bluetooth and establish a connection with external devices. The interaction between the user and our application can be performed with a touch screen. We can even use accelerometer, built-in most of devices, as an alternative UI controller or we can use it for monitoring the activity of the user. New Android API have a feature called Activity Recognition, which allows to detect whether the user is walking, cycling, driving a car, etc. This function uses both GPS and accelerometer. As we can see, the development of mobile applications has a lot of limitations, but it also brings a lot of new possibilities and uncovered areas, which have not been accessible before through traditional applications. Creating such projects can be a great challenge for every software developer. This article describes a few aspects of creating mobile applications, which can help to develop better projects and extend knowledge. Of course, it does not cover all the topics, but it is a good starting point for further research and development.\nDealing with activity lifecycle Before we start developing applications for Android platform, it is important to familiarise with Activity Lifecycle. As the documentation says an activity is a single, focused thing that the user can do and has its own screen and layout associated with it. We have to remember that while the user is using our application, he or she can receive phone call, SMS, push notification from another application, Internet connection can be lost, battery can be low, the phone will start turning off, etc. In addition, the user can rotate the screen of the device, what will cause recreation of the activity. Good practice is to create all important objects in onCreate(Bundle savedInstanceState) method. We have to remember that this method will not be called again, when running activity goes to the background and we call it for the second time. In such case, it will be moved to the top of the activity stack. If we want to execute specific methods every time when we call the activity (no matter, whether it is the first time or not), then we should execute them in onResume() method. Sometimes, the user provides some data into our application and we do not want to lose this data, when an unexpected event will occur. In such case, we can call methods responsible for saving the data and information about the application state in onPause() method. After that, we will be able to retrieve saved information in onResume() method in the future. In specific cases, we can handle configuration changes ourselves, if we want to prevent the recreation of the activity on screen rotation. It can be easily done by manipulating android:configChanges parameter of the activity in AndroidManifest.xml file. Value “orientation|keyboardHidden” will prevent the recreation of the activity. In newer versions of the API, we have to set this parameter to “orientation|keyboardHidden|screenSize”. It is not always necessary, but it is good to know that.\nContext of the activity and application Some methods of Android API, which are responsible for interaction with user interface or accessing resources of the application, requires Context type value as a parameter. Actually, we have two main types of the Context:\nContext of the specific Activity Context of the Application The problem occurs, when we do not know, when to use which and why. In general, when we call the methods, which are responsible for interaction with the UI, we should use Context of the Activity. In addition, when we create custom views, we should also pass Context of the Activity into them. We should do it, because we may lose styles of our application and custom views will be rendered with default Android styles. We also should use this Context, when we perform actions strictly connected with the Activity. When we want to pass Context of the Activity inside Activity, we can simply use this keyword, which contains instance of the Activity, which also represents its Context. There are situations, in which, we can use Context of the Application. It can be done when we access the resources of the application, file paths, strings, data defined in *.xml files and so on. Actually, we should use this context in each case, which is not explicitly related to Activity. In such situations, it is a good practice to create Generic Application and static context in order to standardise the way of accessing it and to be sure that we always access the same object. We can do it in the following way:\npublic class GenericApplication extends Application { private static Application instance; @Override public void onCreate() { super.onCreate(); instance = this; } public static Context getContext() { return instance.getApplicationContext(); } } After that, we have to define GenericApplication in application tag in the android:name attribute.\n","wordCount":"2385","inLanguage":"en","datePublished":"2014-04-07T17:04:00Z","dateModified":"2014-04-07T17:04:00Z","author":{"@type":"Person","name":"Piotr Wittchen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wittchen.io/notes/selected-aspects-of-creating-mobile-android-applications/"},"publisher":{"@type":"Organization","name":"Piotr Wittchen","logo":{"@type":"ImageObject","url":"https://wittchen.io/favicon.ico"}}}</script><script defer data-website-id=dfid_D4sN47CVgrrCRR7KCciN3 data-domain=wittchen.io src=https://datafa.st/js/script.js></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wittchen.io/ accesskey=h title="Piotr Wittchen (Alt + H)">Piotr Wittchen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><button id=menu-toggle class=menu-toggle aria-label="Toggle menu" aria-expanded=false>
<svg class="hamburger-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
<svg class="close-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button><ul id=menu><li><a href=https://wittchen.io/about/ title=about><span>about</span></a></li><li><a href=https://wittchen.io/notes/ title=notes><span>notes</span></a></li><li><a href=https://wittchen.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://wittchen.io/talks/ title=talks><span>talks</span></a></li><li><a href=https://wittchen.io/projects/ title=projects><span>projects</span></a></li><li><a href=https://wittchen.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wittchen.io/>Home</a>&nbsp;»&nbsp;<a href=https://wittchen.io/notes/>Notes</a></div><h1 class="post-title entry-hint-parent">Selected aspects of creating mobile Android applications</h1><div class=post-meta><span title='2014-04-07 17:04:00 +0000 UTC'>April 7, 2014</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;2385 words&nbsp;·&nbsp;Piotr Wittchen&nbsp;|&nbsp;<a href=https://github.com/pwittchen/wittchen.io/blob/master/content/notes/selected-aspects-of-creating-mobile-android-applications.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>During the development of mobile applications, we should adjust our point of view to the specific projects we are working with. Applications for mobile devices are different than desktop or web applications. They have their own lifecycle, work on various devices with different screen resolutions. They have to work on devices with limited memory, clock rate of the CPU and battery life. In addition, these applications often have to be able to work without an Internet connection and their user interface has to be simple and well-designed due to smaller screen of a typical smartphone.</p><p>As we can see, there is a lot of limitations, but there are also plenty of new possibilities. We can use GPS and create location-aware applications. We can access Bluetooth and establish a connection with external devices. The interaction between the user and our application can be performed with a touch screen. We can even use accelerometer, built-in most of devices, as an alternative UI controller or we can use it for monitoring the activity of the user. New Android API have a feature called Activity Recognition, which allows to detect whether the user is walking, cycling, driving a car, etc. This function uses both GPS and accelerometer.
As we can see, the development of mobile applications has a lot of limitations, but it also brings a lot of new possibilities and uncovered areas, which have not been accessible before through traditional applications. Creating such projects can be a great challenge for every software developer. This article describes a few aspects of creating mobile applications, which can help to develop better projects and extend knowledge. Of course, it does not cover all the topics, but it is a good starting point for further research and development.</p><h2 id=dealing-with-activity-lifecycle>Dealing with activity lifecycle<a hidden class=anchor aria-hidden=true href=#dealing-with-activity-lifecycle>#</a></h2><p>Before we start developing applications for Android platform, it is important to familiarise with Activity Lifecycle. As the documentation says an activity is a single, focused thing that the user can do and has its own screen and layout associated with it. We have to remember that while the user is using our application, he or she can receive phone call, SMS, push notification from another application, Internet connection can be lost, battery can be low, the phone will start turning off, etc. In addition, the user can rotate the screen of the device, what will cause recreation of the activity. Good practice is to create all important objects in onCreate(Bundle savedInstanceState) method. We have to remember that this method will not be called again, when running activity goes to the background and we call it for the second time. In such case, it will be moved to the top of the activity stack. If we want to execute specific methods every time when we call the activity (no matter, whether it is the first time or not), then we should execute them in onResume() method. Sometimes, the user provides some data into our application and we do not want to lose this data, when an unexpected event will occur. In such case, we can call methods responsible for saving the data and information about the application state in onPause() method. After that, we will be able to retrieve saved information in onResume() method in the future. In specific cases, we can handle configuration changes ourselves, if we want to prevent the recreation of the activity on screen rotation. It can be easily done by manipulating android:configChanges parameter of the activity in AndroidManifest.xml file. Value “orientation|keyboardHidden” will prevent the recreation of the activity. In newer versions of the API, we have to set this parameter to “orientation|keyboardHidden|screenSize”. It is not always necessary, but it is good to know that.</p><h2 id=context-of-the-activity-and-application>Context of the activity and application<a hidden class=anchor aria-hidden=true href=#context-of-the-activity-and-application>#</a></h2><p>Some methods of Android API, which are responsible for interaction with user interface or accessing resources of the application, requires Context type value as a parameter. Actually, we have two main types of the Context:</p><ul><li>Context of the specific Activity</li><li>Context of the Application</li></ul><p>The problem occurs, when we do not know, when to use which and why. In general, when we call the methods, which are responsible for interaction with the UI, we should use Context of the Activity. In addition, when we create custom views, we should also pass Context of the Activity into them. We should do it, because we may lose styles of our application and custom views will be rendered with default Android styles. We also should use this Context, when we perform actions strictly connected with the Activity. When we want to pass Context of the Activity inside Activity, we can simply use this keyword, which contains instance of the Activity, which also represents its Context.
There are situations, in which, we can use Context of the Application. It can be done when we access the resources of the application, file paths, strings, data defined in <code>*.xml</code> files and so on. Actually, we should use this context in each case, which is not explicitly related to Activity. In such situations, it is a good practice to create Generic Application and static context in order to standardise the way of accessing it and to be sure that we always access the same object. We can do it in the following way:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>GenericApplication</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>Application</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Application</span><span class=w> </span><span class=n>instance</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>onCreate</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>super</span><span class=p>.</span><span class=na>onCreate</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>instance</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>this</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Context</span><span class=w> </span><span class=nf>getContext</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>instance</span><span class=p>.</span><span class=na>getApplicationContext</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>After that, we have to define GenericApplication in application tag in the <code>android:name</code> attribute.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;application</span> <span class=na>android:name=</span><span class=s>&#34;com.futureprocessing.example.generics.GenericApplication&#34;</span><span class=nt>&gt;</span>
</span></span></code></pre></div><p>Now, we will be able to access static Context of the application by calling GenericApplication.getContext() method from any place of our application.</p><h2 id=dependency-injection>Dependency Injection<a hidden class=anchor aria-hidden=true href=#dependency-injection>#</a></h2><p>Dependency Injection as an implementation of Inversion of Control technique allows creating an abstract code with different implementations and follows the Dependency Inversion Principle. In this software design pattern dependent object have injected services. Dependency Injection separates the creation of objects from their behavior. The advantage of this solution is the fact that injected services can be loosely coupled. In addition, there is less lines of code and source of the project becomes clear. There are libraries for Android platform, which have functionality similar to popular Java frameworks dedicated to web applications. One of these solutions is RoboGuice. This is an annotation-based framework, which allows injecting views, resources, system services and POJOs. We do not have to create objects and cast views every time, because the framework will do it for us. Moreover, we can create custom bindings. This can be helpful in many situations. E.g. when one team is working on back-end application, providing web service with data and another team is working on mobile application, which should access this web service. In distributed teams, it may happen that the back-end team is a part of another company or work in a different country than mobile application team. Additionally, web service can be unfinished, but mobile team want to continue the work. In such case, we can create an interface with e.g. getData() method and mock web service implementing this interface. After that, we can bind our interface to mock web service and then inject the interface anywhere in the application. In such situation, application will be using mock data. When proper method responsible for retrieving the data from web service will be created, we can simply change the binding to real web service implementing aforementioned interface. This approach utilises Service Stub pattern, recommended by Martin Fowler. RoboGuice is a very comfortable and elegant solution, but its main drawback is the fact that it uses reflection and dependencies are created in runtime. When we have a lot of dependencies, it can slow down our application. When we face such problem, we can consider using Dagger, which does not use reflection, but generates java files containing dependencies. Those generated files can be compiled, so the application is not responsible for creating dependencies in runtime anymore. Dagger does not support injection of the views. If we want to inject them, we can use Butter Knife library, which is based on concept similar to Dagger.</p><h2 id=single-responsibility-principle>Single Responsibility Principle<a hidden class=anchor aria-hidden=true href=#single-responsibility-principle>#</a></h2><p>Many tutorials and code samples of Android applications are not properly designed. There often is a lot of functionality contained inside single class extending Activity class. It is not a good practice, but in some cases it shows how specific functionality actually works and can be more understandable. Nevertheless, in real life, we should divide our code into smaller pieces, responsible for their own tasks to fulfill Single Responsibility Principle from SOLID concept, which will increase the quality of our code. It is better to understand this idea by looking at an example. Let’s implement a simple MVC pattern, delegate some functionality to the controller and display the result in activity. We can make an assumption that classes extending Activity will be responsible only for displaying the data and UI. Other methods will be accessed from other classes.
First of all, we need to create an interface for our activity.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>interface</span> <span class=nc>SampleView</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>displayData</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>data</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Next, we have to create a controller, which will call the method from the class implementing previously created interface.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>SampleController</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>SampleView</span><span class=w> </span><span class=n>view</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>SampleController</span><span class=p>(</span><span class=n>SampleView</span><span class=w> </span><span class=n>view</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>view</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>view</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>generateData</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>generatedData</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;Exemplary data generated by controller.&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>view</span><span class=p>.</span><span class=na>displayData</span><span class=p>(</span><span class=n>generatedData</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Now, we are ready to create a class extending Activity class and implementing our interface. In this example, we are injecting view with RoboGuice, but we can use findViewById(int) method as well. We can create an object of the controller, assign to its constructor instance of current activity and execute the proper method. Then, the method inside the controller can access the activity through the interface, in order to display the results. Of course, we can call generateData() method anywhere (e.g. after clicking the button).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>SampleActivity</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>Activity</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>SampleView</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@InjectView</span><span class=p>(</span><span class=n>R</span><span class=p>.</span><span class=na>id</span><span class=p>.</span><span class=na>sample_textview</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>sampleTextView</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>SampleController</span><span class=w> </span><span class=n>controller</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>displayData</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>data</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>sampleTextView</span><span class=p>.</span><span class=na>setText</span><span class=p>(</span><span class=n>data</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>protected</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>onCreate</span><span class=p>(</span><span class=n>Bundle</span><span class=w> </span><span class=n>savedInstanceState</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>super</span><span class=p>.</span><span class=na>onCreate</span><span class=p>(</span><span class=n>savedInstanceState</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>controller</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>SampleController</span><span class=p>(</span><span class=k>this</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>protected</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>onResume</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>super</span><span class=p>.</span><span class=na>onResume</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>controller</span><span class=p>.</span><span class=na>generateData</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>After these operations, in this short example we have separated an application logic and specific functions from the methods which operate on user interface. This is just a brief example of using MVC pattern. In bigger projects, we need to implement more complicated structures as well as create additional classes depending on specific cases and requirements.</p><h2 id=multithreading>Multithreading<a hidden class=anchor aria-hidden=true href=#multithreading>#</a></h2><p>Android API allows creating multithreaded applications. It is very useful, when we want our applications to do many things at the same time, when we want to create lazy loading solutions or run some tasks periodically in the background.</p><p>We can distinguish two main classes, which can be used for creating threads:</p><ul><li>Thread</li><li>AsyncTask</li></ul><p>These solutions can be used for different purposes.</p><p>A <strong>Thread</strong> is actually a concurrent unit of execution and it is built-in Java class. That is why, it is not Android-specific. In Android applications, we should use dedicated classes, but we can use Thread class, when we want to write concurrent application with lower level of abstraction. Thread object can be called from any thread with start() method. It runs on its own thread. Its drawback is manual thread management and not so good code readability.</p><p><strong>AsyncTask</strong> is one of the most popular classes used for writing concurrent Android applications. It is usually used for long lasting tasks, which have to communicate with main thread or display the results in UI thread. This class should be used for task, which will be started, executed and finished while the user is accessing a single activity. AsyncTask can be called by execute() method from the main thread. It runs on a worker thread, but may be invoked by the main thread in order to publish the results or progress in the UI. One instance of this class can be executed only once. AsyncTask must be created and executed by the main thread. When activity creating AsyncTask will be destroyed, the thread also will be destroyed and the application will have to create and run it once again in the future.</p><h2 id=long-running-operations>Long running operations<a hidden class=anchor aria-hidden=true href=#long-running-operations>#</a></h2><p>Classes responsible for long running operations are confusing. They are sometimes classified as classes responsible for creating threads or processes, which is common mistake.</p><p>We can distinguish two main classes, which can be used for performing long running operations:</p><ul><li>Service</li><li>IntentService extending Service</li></ul><p><strong>Service</strong> is application component used for running long-lasting tasks. It is neither thread nor process. It is also not connected with UI and should not last too long. We can execute threads (e.g. AsyncTask) within service for long task. In addition, Service can be run periodically. E.g. every 10 seconds, from the time it was started. It will be running even if our application will be send to the background until we decide to stop this thread. Service can be started by onStartService() method and can be executed from any thread. It also runs on the main thread, so a drawback of this class is the fact that it can block the main thread.</p><p><strong>IntentService</strong> is a class extending Service class. It handles asynchronous requests on demand. It can be started by main thread and runs on separate worker thread. It cannot run tasks in parallel. As Android documentation says:</p><blockquote><p>This “work queue processor” pattern is commonly used to offload tasks from an application’s main thread. The IntentService class exists to simplify this pattern and take care of the mechanics. To use it, extend IntentService and implement onHandleIntent(Intent). IntentService will receive the Intents, launch a worker thread, and stop the service as appropriate.</p></blockquote><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>Mobile Android applications are very specific projects, which are different than regular desktop or web applications. They have different lifecycle and different UI, but still some approaches are similar to traditional software solutions. Mobile applications and mobile devices have a lot of limitations. On the other hand, they have a lot of new features, functions and user interaction methods, which have not been available before, what brings new possibilities and fresh ideas. Regardless of the fact that they run on small devices, they are a great challenge for software developers and the future of today’s technology.</p><p><strong>Note</strong>: This article was also published on the Technical Blog of Future Processing company at:
<a href=https://www.future-processing.pl/blog/selected-aspects-of-creating-mobile-android-applications/>https://www.future-processing.pl/blog/selected-aspects-of-creating-mobile-android-applications/</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wittchen.io/tags/android/>Android</a></li></ul><nav class=paginav><a class=prev href=https://wittchen.io/notes/bci-for-mobile-devices-master-thesis-presentation/><span class=title>« Prev</span><br><span>Brain-Computer Interface for mobile devices - Master Thesis presentation</span>
</a><a class=next href=https://wittchen.io/notes/how-to-highlight-and-click-on-listview-item-in-android-programmatically/><span class=title>Next »</span><br><span>How to highlight and click on ListView item in Android programmatically?</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://wittchen.io/>Piotr Wittchen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a> · theme modifications inspired by <a href=https://ui.shadcn.com/ rel=noopener target=_blank>shadcn-ui</a> · <a href=https://github.com/pwittchen/wittchen.io rel=noopener target=_blank>open-source</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){const e=document.querySelector(".header");if(!e)return;function t(){window.scrollY>10?e.classList.add("scrolled"):e.classList.remove("scrolled")}window.addEventListener("scroll",t,{passive:!0}),t()})(),function(){const t=document.getElementById("menu-toggle"),e=document.getElementById("menu");if(!t||!e)return;function s(){const n=t.getAttribute("aria-expanded")==="true";t.setAttribute("aria-expanded",!n),e.classList.toggle("menu-open"),document.body.classList.toggle("menu-open"),n||window.scrollTo(0,0)}function n(){t.setAttribute("aria-expanded","false"),e.classList.remove("menu-open"),document.body.classList.remove("menu-open")}t.addEventListener("click",s),e.querySelectorAll("a").forEach(e=>{e.addEventListener("click",n)}),document.addEventListener("keydown",function(t){t.key==="Escape"&&e.classList.contains("menu-open")&&n()}),window.addEventListener("resize",function(){window.innerWidth>768&&e.classList.contains("menu-open")&&n()})}()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>