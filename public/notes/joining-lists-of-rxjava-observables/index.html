<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Joining lists of RxJava Observables | Piotr Wittchen</title><meta name=keywords content="java,rxjava"><meta name=description content="In RxJava we have a few operators for joining Observables. The most common are:

concat
merge
zip

Take a look at the documentation in these links. It has interactive marble diagrams showing how the operators work on the streams. You can move marbles along the lines and see how the output stream changes. It really helps to understand how it works. Code snippets in this article are based on RxJava 2.1.0 with JUnit 4.12 and Google Truth 0.32 for unit tests. Let&rsquo;s say, we have the following Observables:"><meta name=author content="Piotr Wittchen"><link rel=canonical href=https://wittchen.io/notes/joining-lists-of-rxjava-observables/><link crossorigin=anonymous href=/assets/css/stylesheet.ce07c2a628121ab9051d703ded1d918162d348e5c03783b702262170087c359e.css integrity="sha256-zgfCpigSGrkFHXA97R2RgWLTSOXAN4O3AiYhcAh8NZ4=" rel="preload stylesheet" as=style><link rel=icon href=https://wittchen.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wittchen.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wittchen.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wittchen.io/apple-touch-icon.png><link rel=mask-icon href=https://wittchen.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://wittchen.io/notes/joining-lists-of-rxjava-observables/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wittchen.io/notes/joining-lists-of-rxjava-observables/"><meta property="og:site_name" content="Piotr Wittchen"><meta property="og:title" content="Joining lists of RxJava Observables"><meta property="og:description" content="In RxJava we have a few operators for joining Observables. The most common are:
concat merge zip Take a look at the documentation in these links. It has interactive marble diagrams showing how the operators work on the streams. You can move marbles along the lines and see how the output stream changes. It really helps to understand how it works. Code snippets in this article are based on RxJava 2.1.0 with JUnit 4.12 and Google Truth 0.32 for unit tests. Let’s say, we have the following Observables:"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:published_time" content="2017-05-15T20:37:00+00:00"><meta property="article:modified_time" content="2017-05-15T20:37:00+00:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="Rxjava"><meta name=twitter:card content="summary"><meta name=twitter:title content="Joining lists of RxJava Observables"><meta name=twitter:description content="In RxJava we have a few operators for joining Observables. The most common are:

concat
merge
zip

Take a look at the documentation in these links. It has interactive marble diagrams showing how the operators work on the streams. You can move marbles along the lines and see how the output stream changes. It really helps to understand how it works. Code snippets in this article are based on RxJava 2.1.0 with JUnit 4.12 and Google Truth 0.32 for unit tests. Let&rsquo;s say, we have the following Observables:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://wittchen.io/notes/"},{"@type":"ListItem","position":2,"name":"Joining lists of RxJava Observables","item":"https://wittchen.io/notes/joining-lists-of-rxjava-observables/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Joining lists of RxJava Observables","name":"Joining lists of RxJava Observables","description":"In RxJava we have a few operators for joining Observables. The most common are:\nconcat merge zip Take a look at the documentation in these links. It has interactive marble diagrams showing how the operators work on the streams. You can move marbles along the lines and see how the output stream changes. It really helps to understand how it works. Code snippets in this article are based on RxJava 2.1.0 with JUnit 4.12 and Google Truth 0.32 for unit tests. Let\u0026rsquo;s say, we have the following Observables:\n","keywords":["java","rxjava"],"articleBody":"In RxJava we have a few operators for joining Observables. The most common are:\nconcat merge zip Take a look at the documentation in these links. It has interactive marble diagrams showing how the operators work on the streams. You can move marbles along the lines and see how the output stream changes. It really helps to understand how it works. Code snippets in this article are based on RxJava 2.1.0 with JUnit 4.12 and Google Truth 0.32 for unit tests. Let’s say, we have the following Observables:\npublic Observable\u003cString\u003e emitNumbers() { return Observable.fromArray(\"1\", \"2\", \"3\", \"4\").delay(1, TimeUnit.SECONDS); } public Observable\u003cString\u003e emitLetters() { return Observable.fromArray(\"a\", \"b\", \"c\", \"d\"); } We can merge them in the different ways.\nConcat Concat operator emits the emissions from two or more Observables without interleaving them. We can perform the following operation:\npublic Observable\u003cString\u003e concatStreams() { return Observable.concat(emitNumbers(), emitLetters()); } The easiest way to verify, how this operator works, is to create exploratory unit test as follows:\n@Test public void shouldConcatStreams() { // given Observable\u003cString\u003e observable = playground.concatStreams(); List\u003cString\u003e expectedValues = Arrays.asList(\"1\",\"2\",\"3\",\"4\",\"a\",\"b\",\"c\",\"d\"); List\u003cString\u003e joinedValues = new ArrayList\u003c\u003e(); // when observable.blockingSubscribe(s -\u003e joinedValues.add(s)); // then assertThat(joinedValues).isEqualTo(expectedValues); } This operation can be represented graphically as well.\n1 --- 2 --- 3 --- 4 | a --- b --- c --- d | | concat | \\|/ 1 -- 2 -- 3 -- 4 --- a -- b -- c -- d As we can see one stream is appended to another regardless of the execution time of both streams.\nMerge Merge operator combines multiple Observables into one by merging their emissions. Here we have a similar story, but changed operator:\npublic Observable\u003cString\u003e mergeStreams() { return Observable.merge(emitNumbers(), emitLetters()); } We are writing another unit test:\n@Test public void shouldMergeStreams() { // given Observable\u003cString\u003e observable = playground.mergeStreams(); List\u003cString\u003e expectedValues = Arrays.asList(\"a\",\"b\",\"c\",\"d\",\"1\",\"2\",\"3\",\"4\"); List\u003cString\u003e joinedValues = new ArrayList\u003c\u003e(); // when observable.blockingSubscribe(s -\u003e joinedValues.add(s)); // then assertThat(joinedValues).isEqualTo(expectedValues); } Merge operation should look like that:\n1 --- 2 --- 3 --- 4 | a --- b --- c --- d | | merge | \\|/ a -- b -- c -- d --- 1 -- 2 -- 3 -- 4 This operator doesn’t synchronize the streams and merges them as values are emitted. Numbers are emitted later than letters, so letters are placed in the beginning of the output stream. Try to manipulate marble on the interactive diagram on the reactivex.io website to see how it should work.\nZip The last operator, I’d like to discuss in this article is “Zip” operator. Zip combines the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function. In simple words, it waits until many observables are emitted and then combines them into a pair (or triple Observable, etc. in the case or more Observables). Now, we need to create a function, which will transform our streams and return combined stream.\npublic Observable\u003cString\u003e zipStreams() { return Observable.zip(emitNumbers(), emitLetters(), (s1, s2) -\u003e String.format(\"(%s,%s)\", s1, s2)); } Next, we can verify it with test as usual:\n@Test public void shouldZipStreams() { // given Observable\u003cString\u003e observable = playground.zipStreams(); List\u003cString\u003e expectedValues = Arrays.asList(\"(1,a)\",\"(2,b)\",\"(3,c)\",\"(4,d)\"); List\u003cString\u003e joinedValues = new ArrayList\u003c\u003e(); // when observable.blockingSubscribe(s -\u003e joinedValues.add(s)); // then assertThat(joinedValues).isEqualTo(expectedValues); } and it can be represented graphically like that:\n1 --- 2 --- 3 --- 4 | a --- b --- c --- d | | zip | \\|/ (1,a) -- (2,b) --- (3,c) -- (4,d) Now, we have pairs of merged streams.\nSummary Of course, RxJava is complicated library and these methods are not covering all possibilities of merging and combining the Observable streams. Neverhteless, examples in this article are quite basic and may help you to understand how mentioned operators work. After that we can apply the best operator to appropriate situation.\nReference thread on StackOverflow: http://stackoverflow.com/questions/28843318/android-rxjava-joining-lists\n","wordCount":"638","inLanguage":"en","datePublished":"2017-05-15T20:37:00Z","dateModified":"2017-05-15T20:37:00Z","author":{"@type":"Person","name":"Piotr Wittchen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wittchen.io/notes/joining-lists-of-rxjava-observables/"},"publisher":{"@type":"Organization","name":"Piotr Wittchen","logo":{"@type":"ImageObject","url":"https://wittchen.io/favicon.ico"}}}</script><script defer data-website-id=dfid_D4sN47CVgrrCRR7KCciN3 data-domain=wittchen.io src=https://datafa.st/js/script.js></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wittchen.io/ accesskey=h title="Piotr Wittchen (Alt + H)">Piotr Wittchen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><button id=menu-toggle class=menu-toggle aria-label="Toggle menu" aria-expanded=false>
<svg class="hamburger-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
<svg class="close-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button><ul id=menu><li><a href=https://wittchen.io/about/ title=about><span>about</span></a></li><li><a href=https://wittchen.io/notes/ title=notes><span>notes</span></a></li><li><a href=https://wittchen.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://wittchen.io/talks/ title=talks><span>talks</span></a></li><li><a href=https://wittchen.io/projects/ title=projects><span>projects</span></a></li><li><a href=https://wittchen.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wittchen.io/>Home</a>&nbsp;»&nbsp;<a href=https://wittchen.io/notes/>Notes</a></div><h1 class="post-title entry-hint-parent">Joining lists of RxJava Observables</h1><div class=post-meta><span title='2017-05-15 20:37:00 +0000 UTC'>May 15, 2017</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;638 words&nbsp;·&nbsp;Piotr Wittchen&nbsp;|&nbsp;<a href=https://github.com/pwittchen/wittchen.io/blob/master/content/notes/joining-lists-of-rxjava-observables.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>In <a href=https://github.com/ReactiveX/RxJava>RxJava</a> we have a few operators for joining Observables. The most common are:</p><ul><li><a href=http://reactivex.io/documentation/operators/concat.html>concat</a></li><li><a href=http://reactivex.io/documentation/operators/merge.html>merge</a></li><li><a href=http://reactivex.io/documentation/operators/zip.html>zip</a></li></ul><p>Take a look at the documentation in these links. It has <strong>interactive marble diagrams</strong> showing how the operators work on the streams. You can move marbles along the lines and see how the output stream changes. It really helps to understand how it works. Code snippets in this article are based on RxJava 2.1.0 with JUnit 4.12 and Google Truth 0.32 for unit tests. Let&rsquo;s say, we have the following Observables:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=n>Observable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=nf>emitNumbers</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>Observable</span><span class=p>.</span><span class=na>fromArray</span><span class=p>(</span><span class=s>&#34;1&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;2&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;3&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;4&#34;</span><span class=p>).</span><span class=na>delay</span><span class=p>(</span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>TimeUnit</span><span class=p>.</span><span class=na>SECONDS</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=n>Observable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=nf>emitLetters</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>Observable</span><span class=p>.</span><span class=na>fromArray</span><span class=p>(</span><span class=s>&#34;a&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;b&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;c&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;d&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>We can merge them in the different ways.</p><h2 id=concat><a href=http://reactivex.io/documentation/operators/concat.html>Concat</a><a hidden class=anchor aria-hidden=true href=#concat>#</a></h2><p>Concat operator <em>emits the emissions from two or more Observables without interleaving them</em>. We can perform the following operation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=n>Observable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=nf>concatStreams</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>Observable</span><span class=p>.</span><span class=na>concat</span><span class=p>(</span><span class=n>emitNumbers</span><span class=p>(),</span><span class=w> </span><span class=n>emitLetters</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>The easiest way to verify, how this operator works, is to create exploratory unit test as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>shouldConcatStreams</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// given</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Observable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>observable</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>playground</span><span class=p>.</span><span class=na>concatStreams</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>expectedValues</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Arrays</span><span class=p>.</span><span class=na>asList</span><span class=p>(</span><span class=s>&#34;1&#34;</span><span class=p>,</span><span class=s>&#34;2&#34;</span><span class=p>,</span><span class=s>&#34;3&#34;</span><span class=p>,</span><span class=s>&#34;4&#34;</span><span class=p>,</span><span class=s>&#34;a&#34;</span><span class=p>,</span><span class=s>&#34;b&#34;</span><span class=p>,</span><span class=s>&#34;c&#34;</span><span class=p>,</span><span class=s>&#34;d&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>joinedValues</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ArrayList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// when</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>observable</span><span class=p>.</span><span class=na>blockingSubscribe</span><span class=p>(</span><span class=n>s</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>joinedValues</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>s</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// then</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>assertThat</span><span class=p>(</span><span class=n>joinedValues</span><span class=p>).</span><span class=na>isEqualTo</span><span class=p>(</span><span class=n>expectedValues</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>This operation can be represented graphically as well.</p><pre tabindex=0><code>         1 --- 2 --- 3 --- 4
                  |
         a --- b --- c --- d
                  |
                  |
                concat
                  |
                 \|/
1 -- 2 -- 3 -- 4 --- a -- b -- c -- d
</code></pre><p>As we can see one stream is appended to another regardless of the execution time of both streams.</p><h2 id=merge><a href=http://reactivex.io/documentation/operators/merge.html>Merge</a><a hidden class=anchor aria-hidden=true href=#merge>#</a></h2><p>Merge operator <em>combines multiple Observables into one by merging their emissions</em>. Here we have a similar story, but changed operator:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=n>Observable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=nf>mergeStreams</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>Observable</span><span class=p>.</span><span class=na>merge</span><span class=p>(</span><span class=n>emitNumbers</span><span class=p>(),</span><span class=w> </span><span class=n>emitLetters</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>We are writing another unit test:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>shouldMergeStreams</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// given</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Observable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>observable</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>playground</span><span class=p>.</span><span class=na>mergeStreams</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>expectedValues</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Arrays</span><span class=p>.</span><span class=na>asList</span><span class=p>(</span><span class=s>&#34;a&#34;</span><span class=p>,</span><span class=s>&#34;b&#34;</span><span class=p>,</span><span class=s>&#34;c&#34;</span><span class=p>,</span><span class=s>&#34;d&#34;</span><span class=p>,</span><span class=s>&#34;1&#34;</span><span class=p>,</span><span class=s>&#34;2&#34;</span><span class=p>,</span><span class=s>&#34;3&#34;</span><span class=p>,</span><span class=s>&#34;4&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>joinedValues</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ArrayList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// when</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>observable</span><span class=p>.</span><span class=na>blockingSubscribe</span><span class=p>(</span><span class=n>s</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>joinedValues</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>s</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// then</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>assertThat</span><span class=p>(</span><span class=n>joinedValues</span><span class=p>).</span><span class=na>isEqualTo</span><span class=p>(</span><span class=n>expectedValues</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Merge operation should look like that:</p><pre tabindex=0><code>         1 --- 2 --- 3 --- 4
                  |
         a --- b --- c --- d
                  |
                  |
                merge
                  |
                 \|/
a -- b -- c -- d --- 1 -- 2 -- 3 -- 4
</code></pre><p>This operator doesn&rsquo;t synchronize the streams and merges them as values are emitted. Numbers are emitted later than letters, so letters are placed in the beginning of the output stream. Try to manipulate marble on the interactive diagram on the <a href=http://reactivex.io>reactivex.io</a> website to see how it should work.</p><h2 id=zip><a href=http://reactivex.io/documentation/operators/zip.html>Zip</a><a hidden class=anchor aria-hidden=true href=#zip>#</a></h2><p>The last operator, I&rsquo;d like to discuss in this article is &ldquo;Zip&rdquo; operator. Zip <em>combines the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function</em>. In simple words, it waits until many observables are emitted and then combines them into a pair (or triple Observable, etc. in the case or more Observables). Now, we need to create a function, which will transform our streams and return combined stream.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=n>Observable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=nf>zipStreams</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>Observable</span><span class=p>.</span><span class=na>zip</span><span class=p>(</span><span class=n>emitNumbers</span><span class=p>(),</span><span class=w> </span><span class=n>emitLetters</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>(</span><span class=n>s1</span><span class=p>,</span><span class=w> </span><span class=n>s2</span><span class=p>)</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>String</span><span class=p>.</span><span class=na>format</span><span class=p>(</span><span class=s>&#34;(%s,%s)&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s1</span><span class=p>,</span><span class=w> </span><span class=n>s2</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Next, we can verify it with test as usual:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>shouldZipStreams</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// given</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Observable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>observable</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>playground</span><span class=p>.</span><span class=na>zipStreams</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>expectedValues</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Arrays</span><span class=p>.</span><span class=na>asList</span><span class=p>(</span><span class=s>&#34;(1,a)&#34;</span><span class=p>,</span><span class=s>&#34;(2,b)&#34;</span><span class=p>,</span><span class=s>&#34;(3,c)&#34;</span><span class=p>,</span><span class=s>&#34;(4,d)&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>joinedValues</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ArrayList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// when</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>observable</span><span class=p>.</span><span class=na>blockingSubscribe</span><span class=p>(</span><span class=n>s</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>joinedValues</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>s</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// then</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>assertThat</span><span class=p>(</span><span class=n>joinedValues</span><span class=p>).</span><span class=na>isEqualTo</span><span class=p>(</span><span class=n>expectedValues</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>and it can be represented graphically like that:</p><pre tabindex=0><code>        1 --- 2 --- 3 --- 4
                 |
        a --- b --- c --- d
                 |
                 |
                zip
                 |
                \|/
 (1,a) -- (2,b) --- (3,c) -- (4,d)
</code></pre><p>Now, we have pairs of merged streams.</p><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>Of course, RxJava is complicated library and these methods are not covering all possibilities of merging and combining the Observable streams. Neverhteless, examples in this article are quite basic and may help you to understand how mentioned operators work. After that we can apply the best operator to appropriate situation.</p><hr><p>Reference thread on StackOverflow: <a href=http://stackoverflow.com/questions/28843318/android-rxjava-joining-lists>http://stackoverflow.com/questions/28843318/android-rxjava-joining-lists</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wittchen.io/tags/java/>Java</a></li><li><a href=https://wittchen.io/tags/rxjava/>Rxjava</a></li></ul><nav class=paginav><a class=prev href=https://wittchen.io/notes/prefser-207/><span class=title>« Prev</span><br><span>Releasing Prefser v. 2.0.7</span>
</a><a class=next href=https://wittchen.io/notes/emitting-different-rxjava-observables-depending-on-the-condition-with-flatmap/><span class=title>Next »</span><br><span>Emitting different observables conditionally</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://wittchen.io/>Piotr Wittchen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a> · theme modifications inspired by <a href=https://ui.shadcn.com/ rel=noopener target=_blank>shadcn-ui</a> · <a href=https://github.com/pwittchen/wittchen.io rel=noopener target=_blank>open-source</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){const e=document.querySelector(".header");if(!e)return;function t(){window.scrollY>10?e.classList.add("scrolled"):e.classList.remove("scrolled")}window.addEventListener("scroll",t,{passive:!0}),t()})(),function(){const t=document.getElementById("menu-toggle"),e=document.getElementById("menu");if(!t||!e)return;function s(){const n=t.getAttribute("aria-expanded")==="true";t.setAttribute("aria-expanded",!n),e.classList.toggle("menu-open"),document.body.classList.toggle("menu-open"),n||window.scrollTo(0,0)}function n(){t.setAttribute("aria-expanded","false"),e.classList.remove("menu-open"),document.body.classList.remove("menu-open")}t.addEventListener("click",s),e.querySelectorAll("a").forEach(e=>{e.addEventListener("click",n)}),document.addEventListener("keydown",function(t){t.key==="Escape"&&e.classList.contains("menu-open")&&n()}),window.addEventListener("resize",function(){window.innerWidth>768&&e.classList.contains("menu-open")&&n()})}()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>