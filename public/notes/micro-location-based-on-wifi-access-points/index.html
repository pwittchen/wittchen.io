<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Micro-location based on WiFi Access Points | Piotr Wittchen</title><meta name=keywords content="android,java"><meta name=description content="Introduction
Recently, I started working on quite interesting project. One of its elements is micro-location inside the building based on WiFi Access Points. Company&rsquo;s buildings have a lot of Access Points in different locations like regular rooms, conference rooms, corridors, sports building and restaurant. Having pool of Access Points with their names, locations and MAC addresses (or more precisely: BSSID) it&rsquo;s possible to create micro-location for Android mobile devices.
Overview
On the image below, you can see approximate location of WiFi Access Points in the F3 building of Future Processing company. Other buildings also have their own Access Points, but they weren&rsquo;t taken into consideration during the initial experiment. Android gives us possibility to scan available WiFi Access Points and measure their signal strength. Appropriate BroadcastReceiver allows us to react on event of changing WiFi Access Points signal strength, what can be interpreted as movement of person having mobile device. When such event occurs, we can read list of available Access Points, measure their signal strength, detect Access Point with the strongest signal, map it to specific room location and start WiFi scan again in order to retrieve fresh list of the Access Points as soon as possible. We have to remember that WiFi scanning is an asynchronous operation, so we don&rsquo;t know, when we receive the results. That&rsquo;s why event-driven development is good approach in such case. We can use pure Android BroadcastReceiver or use Otto Event Bus to make our code annotation-based, fine-grained and clear."><meta name=author content="Piotr Wittchen"><link rel=canonical href=https://wittchen.io/notes/micro-location-based-on-wifi-access-points/><link crossorigin=anonymous href=/assets/css/stylesheet.64cd9f7ad966be97143f92168e85cd8b50f324e8c98aaa2bae74321d2bbeb260.css integrity="sha256-ZM2fetlmvpcUP5IWjoXNi1DzJOjJiqorrnQyHSu+smA=" rel="preload stylesheet" as=style><link rel=icon href=https://wittchen.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wittchen.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wittchen.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wittchen.io/apple-touch-icon.png><link rel=mask-icon href=https://wittchen.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://wittchen.io/notes/micro-location-based-on-wifi-access-points/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wittchen.io/notes/micro-location-based-on-wifi-access-points/"><meta property="og:site_name" content="Piotr Wittchen"><meta property="og:title" content="Micro-location based on WiFi Access Points"><meta property="og:description" content="Introduction Recently, I started working on quite interesting project. One of its elements is micro-location inside the building based on WiFi Access Points. Company’s buildings have a lot of Access Points in different locations like regular rooms, conference rooms, corridors, sports building and restaurant. Having pool of Access Points with their names, locations and MAC addresses (or more precisely: BSSID) it’s possible to create micro-location for Android mobile devices.
Overview On the image below, you can see approximate location of WiFi Access Points in the F3 building of Future Processing company. Other buildings also have their own Access Points, but they weren’t taken into consideration during the initial experiment. Android gives us possibility to scan available WiFi Access Points and measure their signal strength. Appropriate BroadcastReceiver allows us to react on event of changing WiFi Access Points signal strength, what can be interpreted as movement of person having mobile device. When such event occurs, we can read list of available Access Points, measure their signal strength, detect Access Point with the strongest signal, map it to specific room location and start WiFi scan again in order to retrieve fresh list of the Access Points as soon as possible. We have to remember that WiFi scanning is an asynchronous operation, so we don’t know, when we receive the results. That’s why event-driven development is good approach in such case. We can use pure Android BroadcastReceiver or use Otto Event Bus to make our code annotation-based, fine-grained and clear."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:published_time" content="2014-09-21T13:16:00+00:00"><meta property="article:modified_time" content="2014-09-21T13:16:00+00:00"><meta property="article:tag" content="Android"><meta property="article:tag" content="Java"><meta name=twitter:card content="summary"><meta name=twitter:title content="Micro-location based on WiFi Access Points"><meta name=twitter:description content="Introduction
Recently, I started working on quite interesting project. One of its elements is micro-location inside the building based on WiFi Access Points. Company&rsquo;s buildings have a lot of Access Points in different locations like regular rooms, conference rooms, corridors, sports building and restaurant. Having pool of Access Points with their names, locations and MAC addresses (or more precisely: BSSID) it&rsquo;s possible to create micro-location for Android mobile devices.
Overview
On the image below, you can see approximate location of WiFi Access Points in the F3 building of Future Processing company. Other buildings also have their own Access Points, but they weren&rsquo;t taken into consideration during the initial experiment. Android gives us possibility to scan available WiFi Access Points and measure their signal strength. Appropriate BroadcastReceiver allows us to react on event of changing WiFi Access Points signal strength, what can be interpreted as movement of person having mobile device. When such event occurs, we can read list of available Access Points, measure their signal strength, detect Access Point with the strongest signal, map it to specific room location and start WiFi scan again in order to retrieve fresh list of the Access Points as soon as possible. We have to remember that WiFi scanning is an asynchronous operation, so we don&rsquo;t know, when we receive the results. That&rsquo;s why event-driven development is good approach in such case. We can use pure Android BroadcastReceiver or use Otto Event Bus to make our code annotation-based, fine-grained and clear."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://wittchen.io/notes/"},{"@type":"ListItem","position":2,"name":"Micro-location based on WiFi Access Points","item":"https://wittchen.io/notes/micro-location-based-on-wifi-access-points/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Micro-location based on WiFi Access Points","name":"Micro-location based on WiFi Access Points","description":"Introduction Recently, I started working on quite interesting project. One of its elements is micro-location inside the building based on WiFi Access Points. Company\u0026rsquo;s buildings have a lot of Access Points in different locations like regular rooms, conference rooms, corridors, sports building and restaurant. Having pool of Access Points with their names, locations and MAC addresses (or more precisely: BSSID) it\u0026rsquo;s possible to create micro-location for Android mobile devices.\nOverview On the image below, you can see approximate location of WiFi Access Points in the F3 building of Future Processing company. Other buildings also have their own Access Points, but they weren\u0026rsquo;t taken into consideration during the initial experiment. Android gives us possibility to scan available WiFi Access Points and measure their signal strength. Appropriate BroadcastReceiver allows us to react on event of changing WiFi Access Points signal strength, what can be interpreted as movement of person having mobile device. When such event occurs, we can read list of available Access Points, measure their signal strength, detect Access Point with the strongest signal, map it to specific room location and start WiFi scan again in order to retrieve fresh list of the Access Points as soon as possible. We have to remember that WiFi scanning is an asynchronous operation, so we don\u0026rsquo;t know, when we receive the results. That\u0026rsquo;s why event-driven development is good approach in such case. We can use pure Android BroadcastReceiver or use Otto Event Bus to make our code annotation-based, fine-grained and clear.\n","keywords":["android","java"],"articleBody":"Introduction Recently, I started working on quite interesting project. One of its elements is micro-location inside the building based on WiFi Access Points. Company’s buildings have a lot of Access Points in different locations like regular rooms, conference rooms, corridors, sports building and restaurant. Having pool of Access Points with their names, locations and MAC addresses (or more precisely: BSSID) it’s possible to create micro-location for Android mobile devices.\nOverview On the image below, you can see approximate location of WiFi Access Points in the F3 building of Future Processing company. Other buildings also have their own Access Points, but they weren’t taken into consideration during the initial experiment. Android gives us possibility to scan available WiFi Access Points and measure their signal strength. Appropriate BroadcastReceiver allows us to react on event of changing WiFi Access Points signal strength, what can be interpreted as movement of person having mobile device. When such event occurs, we can read list of available Access Points, measure their signal strength, detect Access Point with the strongest signal, map it to specific room location and start WiFi scan again in order to retrieve fresh list of the Access Points as soon as possible. We have to remember that WiFi scanning is an asynchronous operation, so we don’t know, when we receive the results. That’s why event-driven development is good approach in such case. We can use pure Android BroadcastReceiver or use Otto Event Bus to make our code annotation-based, fine-grained and clear.\nOriginal image comes from www.future-processing.com website.\nImplementation To implement micro-location I used open-source NetworkEvents Android library, which I have written earlier and described in one of my previous blog posts. First, we should create AccessPoint model.\npublic class AccessPoint { private String mac; private String keyName; private String fineName; public AccessPoint() { } public AccessPoint(String mac, String keyName, String fineName) { this.mac = mac; this.keyName = keyName; this.fineName = fineName; } public String getMac() { return mac; } public String getKeyName() { return keyName; } public String getFineName() { return fineName; } } AccessPoint class can cotain mac address of the particular Access Point, keyName as additional identifier of the Access Point location and fineName containing readable name of the Access Point location, which can be displayed for the user. After that, we have to create RoomLocator class. This class contains getNearestAccessPoint() method, which reads list of the available Access Points and returns one with the strongest signal. We have to remember, that we have to fill accessPointsRoomList HashMap with our map of the Access Points. In this case, MAC address of the Access Point, which is String value, should be treated as a key in the HashMap.\npublic class RoomLocator { private static Map\u003cString, AccessPoint\u003e accessPointsRoomList = new HashMap\u003c\u003e(); public AccessPoint getNearestAccessPoint() { WifiManager wifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE); List\u003cScanResult\u003e accessPointsScanResult = wifiManager.getScanResults(); AccessPoint nearestAccessPoint = null; ScanResult bestSignal = null; String currentNearestBSSID; for (ScanResult scanResult : accessPointsScanResult) { currentNearestBSSID = scanResult.BSSID.toUpperCase(); if (!accessPointsRoomList.containsKey(currentNearestBSSID)) { continue; } if (bestSignal == null || WifiManager.compareSignalLevel(bestSignal.level, scanResult.level) \u003c 0) { nearestAccessPoint = accessPointsRoomList.get(currentNearestBSSID); bestSignal = scanResult; } } return nearestAccessPoint; } } After that, we can use NetworkEvents to listen, when signal strength of the Access Points is being changed. This usually happens, when user is moving with the smartphone. We can do that very easily with @Subscribe annotation. When mentioned event occurs, we can call getNearestAccessPoint() method from RoomLocator class. Of course, we can create provider for this class and access it in static way. In addition, please read my previous post about Network Events library if you want to know, how to use it properly.\n@Subscribe public void wifiAccessPointsRefreshed(WifiAccessPointsSignalStrengthChangedEvent event) { AccessPoint accessPoint = new RoomLocator().getNearestAccessPoint(); Toast.makeText(this, accessPoint.getFineName(), Toast.LENGTH_SHORT).show(); } That’s it. Every time, when WifiAccessPointsSignalStrengthChangedEvent will occur, you will get fresh information about Access Point with the strongest signal, which can be treated as your location. I’ve tested this solution and it actually works. Please remember that such application can work only in buildings with many different Access Points in different rooms on different floors (usually in IT companies).\n","wordCount":"676","inLanguage":"en","datePublished":"2014-09-21T13:16:00Z","dateModified":"2014-09-21T13:16:00Z","author":{"@type":"Person","name":"Piotr Wittchen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wittchen.io/notes/micro-location-based-on-wifi-access-points/"},"publisher":{"@type":"Organization","name":"Piotr Wittchen","logo":{"@type":"ImageObject","url":"https://wittchen.io/favicon.ico"}}}</script><script defer data-website-id=dfid_D4sN47CVgrrCRR7KCciN3 data-domain=wittchen.io src=https://datafa.st/js/script.js></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wittchen.io/ accesskey=h title="Piotr Wittchen (Alt + H)">Piotr Wittchen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wittchen.io/notes/ title=notes><span>notes</span></a></li><li><a href=https://wittchen.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://wittchen.io/talks/ title=talks><span>talks</span></a></li><li><a href=https://wittchen.io/projects/ title=projects><span>projects</span></a></li><li><a href=https://wittchen.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://wittchen.io/contact/ title=contact><span>contact</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wittchen.io/>Home</a>&nbsp;»&nbsp;<a href=https://wittchen.io/notes/>Notes</a></div><h1 class="post-title entry-hint-parent">Micro-location based on WiFi Access Points</h1><div class=post-meta><span title='2014-09-21 13:16:00 +0000 UTC'>September 21, 2014</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;676 words&nbsp;·&nbsp;Piotr Wittchen&nbsp;|&nbsp;<a href=https://github.com/pwittchen/wittchen.io/blob/master/content/notes/micro-location-based-on-wifi-access-points.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>Recently, I started working on quite interesting project. One of its elements is micro-location inside the building based on WiFi Access Points. Company&rsquo;s buildings have a lot of Access Points in different locations like regular rooms, conference rooms, corridors, sports building and restaurant. Having pool of Access Points with their names, locations and <a href=http://en.wikipedia.org/wiki/MAC_address>MAC</a> addresses (or more precisely: <a href=http://en.wiktionary.org/wiki/BSSID>BSSID</a>) it&rsquo;s possible to create micro-location for Android mobile devices.</p><h2 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h2><p>On the image below, you can see approximate location of WiFi Access Points in the F3 building of Future Processing company. Other buildings also have their own Access Points, but they weren&rsquo;t taken into consideration during the initial experiment. Android gives us possibility to scan available WiFi Access Points and measure their signal strength. Appropriate <a href=http://developer.android.com/reference/android/content/BroadcastReceiver.html>BroadcastReceiver</a> allows us to react on event of changing WiFi Access Points signal strength, what can be interpreted as movement of person having mobile device. When such event occurs, we can read list of available Access Points, measure their signal strength, detect Access Point with the strongest signal, map it to specific room location and start WiFi scan again in order to retrieve fresh list of the Access Points as soon as possible. We have to remember that WiFi scanning is an asynchronous operation, so we don&rsquo;t know, when we receive the results. That&rsquo;s why event-driven development is good approach in such case. We can use pure Android BroadcastReceiver or use <a href=http://square.github.io/otto/>Otto Event Bus</a> to make our code annotation-based, fine-grained and clear.</p><p><img alt=fp-buildings-hot-spots loading=lazy src=/posts/2014/micro-location-based-on-wifi-access-points/fp-buildings-hot-spots.png></p><p><em>Original image comes from <a href=http://www.future-processing.com>www.future-processing.com</a> website.</em></p><h2 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h2><p>To implement micro-location I used open-source <a href=https://github.com/pwittchen/NetworkEvents>NetworkEvents</a> Android library, which I have written earlier and described in <a href=http://blog.wittchen.biz.pl/networkevents-android-library/>one of my previous blog posts</a>. First, we should create <code>AccessPoint</code> model.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>AccessPoint</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>mac</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>keyName</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>fineName</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>AccessPoint</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>AccessPoint</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>mac</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>keyName</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>fineName</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>mac</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mac</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>keyName</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>keyName</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>fineName</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>fineName</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>getMac</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>mac</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>getKeyName</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>keyName</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>getFineName</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>fineName</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><code>AccessPoint</code> class can cotain <code>mac</code> address of the particular Access Point, <code>keyName</code> as additional identifier of the Access Point location and <code>fineName</code> containing readable name of the Access Point location, which can be displayed for the user. After that, we have to create <code>RoomLocator</code> class. This class contains <code>getNearestAccessPoint()</code> method, which reads list of the available Access Points and returns one with the strongest signal. We have to remember, that <strong>we have to fill</strong> <code>accessPointsRoomList</code> <strong>HashMap with our map of the Access Points</strong>. In this case, MAC address of the Access Point, which is String value, should be treated as a key in the HashMap.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>RoomLocator</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>AccessPoint</span><span class=o>&gt;</span><span class=w> </span><span class=n>accessPointsRoomList</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>HashMap</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>AccessPoint</span><span class=w> </span><span class=nf>getNearestAccessPoint</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>WifiManager</span><span class=w> </span><span class=n>wifiManager</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>WifiManager</span><span class=p>)</span><span class=w> </span><span class=n>context</span><span class=p>.</span><span class=na>getSystemService</span><span class=p>(</span><span class=n>Context</span><span class=p>.</span><span class=na>WIFI_SERVICE</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>List</span><span class=o>&lt;</span><span class=n>ScanResult</span><span class=o>&gt;</span><span class=w> </span><span class=n>accessPointsScanResult</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>wifiManager</span><span class=p>.</span><span class=na>getScanResults</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>AccessPoint</span><span class=w> </span><span class=n>nearestAccessPoint</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ScanResult</span><span class=w> </span><span class=n>bestSignal</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>currentNearestBSSID</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>ScanResult</span><span class=w> </span><span class=n>scanResult</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>accessPointsScanResult</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>currentNearestBSSID</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>scanResult</span><span class=p>.</span><span class=na>BSSID</span><span class=p>.</span><span class=na>toUpperCase</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>accessPointsRoomList</span><span class=p>.</span><span class=na>containsKey</span><span class=p>(</span><span class=n>currentNearestBSSID</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>continue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>bestSignal</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>WifiManager</span><span class=p>.</span><span class=na>compareSignalLevel</span><span class=p>(</span><span class=n>bestSignal</span><span class=p>.</span><span class=na>level</span><span class=p>,</span><span class=w> </span><span class=n>scanResult</span><span class=p>.</span><span class=na>level</span><span class=p>)</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>nearestAccessPoint</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>accessPointsRoomList</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>currentNearestBSSID</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>bestSignal</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>scanResult</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>nearestAccessPoint</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>After that, we can use <a href=https://github.com/pwittchen/NetworkEvents>NetworkEvents</a> to listen, when signal strength of the Access Points is being changed. This usually happens, when user is moving with the smartphone. We can do that very easily with <code>@Subscribe</code> annotation. When mentioned event occurs, we can call <code>getNearestAccessPoint()</code> method from <code>RoomLocator</code> class. Of course, we can create provider for this class and access it in static way. In addition, please read <a href=http://blog.wittchen.biz.pl/networkevents-android-library/>my previous post about Network Events</a> library if you want to know, how to use it properly.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Subscribe</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>wifiAccessPointsRefreshed</span><span class=p>(</span><span class=n>WifiAccessPointsSignalStrengthChangedEvent</span><span class=w> </span><span class=n>event</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>AccessPoint</span><span class=w> </span><span class=n>accessPoint</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>RoomLocator</span><span class=p>().</span><span class=na>getNearestAccessPoint</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>Toast</span><span class=p>.</span><span class=na>makeText</span><span class=p>(</span><span class=k>this</span><span class=p>,</span><span class=w> </span><span class=n>accessPoint</span><span class=p>.</span><span class=na>getFineName</span><span class=p>(),</span><span class=w> </span><span class=n>Toast</span><span class=p>.</span><span class=na>LENGTH_SHORT</span><span class=p>).</span><span class=na>show</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>That&rsquo;s it. Every time, when <code>WifiAccessPointsSignalStrengthChangedEvent</code> will occur, you will get fresh information about Access Point with the strongest signal, which can be treated as your location. I&rsquo;ve tested this solution and it actually works. Please remember that such application can work only in buildings with many different Access Points in different rooms on different floors (usually in IT companies).</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wittchen.io/tags/android/>Android</a></li><li><a href=https://wittchen.io/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=https://wittchen.io/notes/weather-icons-for-android-applications/><span class=title>« Prev</span><br><span>Weather Icons for Android applications</span>
</a><a class=next href=https://wittchen.io/notes/versioning-android-applications/><span class=title>Next »</span><br><span>Versioning Android applications</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://wittchen.io/>Piotr Wittchen</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a> (modified | inspired by <a href=https://ui.shadcn.com/ rel=noopener target=_blank>shadcn-ui</a>)</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){const e=document.querySelector(".header");if(!e)return;function t(){window.scrollY>10?e.classList.add("scrolled"):e.classList.remove("scrolled")}window.addEventListener("scroll",t,{passive:!0}),t()})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>